< 첨부형 게시판 실제 작업 순서 >

1. SQL작성

2. UploadDto 작성
@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder      // 쉬운 생성을 도와주는 빌더패턴
public class UploadDto {
  private int uploadNo;
  private String title;
  private String contents;
  private String createdAt;
  private String modifiedAt;
  private UserDto userDto;    // private int userNo 를 대체함.
}


3. AttachDto 작성
@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder      // 쉬운 생성을 도와주는 빌더패턴
public class AttachDto {
  private int attachNo;
  private String path;
  private String originalFilename;
  private String filesystemName;
  private int downloadCount;
  private int hasThumbnail;
  private int uploadNo;
}


4. mybatis-config.xml 별명 등록
<configuration>
    
  <!-- 설정 -->
  <settings>
    <setting name="mapUnderscoreToCamelCase" value="true"/>
  </settings>
  
  <typeAliases>
    <typeAlias alias="UserDto"         type="com.gdu.myhome.dto.UserDto"/>
    <typeAlias alias="LeaveUserDto"    type="com.gdu.myhome.dto.LeaveUserDto"/>
    <typeAlias alias="InactiveUserDto" type="com.gdu.myhome.dto.InactiveUserDto"/>
    <typeAlias alias="FreeDto"         type="com.gdu.myhome.dto.FreeDto"/>
    <typeAlias alias="BlogDto"         type="com.gdu.myhome.dto.BlogDto"/>
    <typeAlias alias="BlogImageDto"    type="com.gdu.myhome.dto.BlogImageDto"/>
    <typeAlias alias="CommentDto"      type="com.gdu.myhome.dto.CommentDto"/>
    <typeAlias alias="UploadDto"       type="com.gdu.myhome.dto.UploadDto"/>   <- 이거 추가.
    <typeAlias alias="AttachDto"       type="com.gdu.myhome.dto.AttachDto"/>
  </typeAliases>

</configuration>


5. mapper 폴더에 UploadMapper.xml 만들기
<mapper namespace="com.gdu.myhome.dao.UploadMapper">

</mapper>


6. 서비스 인터페이스 와 서비스임플 클래스(서비스인터페이스 추가) 만들기.
서비스임플에 @Service 붙이기.


7. UploadMapper 인터페이스로 만들기.
@RequiredArgsConstructor
@Service
public class UploadServiceImpl implements UploadService {

  private final UploadMapper uploadMapper;  // 매퍼 이용할 용도
  private final MyFileUtils myFileUtils;    // 파일첨부할 용도
  private final MyPageUtils myPageUtils;    // 목록 다룰 용도
  
}


8. UploadController 만들기.
@RequiredArgsConstructor
@Controller
public class UploadController {

  private final UploadService uploadService;  // 컨트롤러가 사용할 서비스
  
}


9. views 폴더에 upload 폴더 만들고 list.jsp 만들기.


10. Thumbnail 만드는 dependency 추가 (메이븐 사이트 : thumbnailator 검색후 첫 번째 항목)
<!-- 썸네일 자동 생성 -->
<!-- https://mvnrepository.com/artifact/net.coobird/thumbnailator -->
<dependency>
    <groupId>net.coobird</groupId>
    <artifactId>thumbnailator</artifactId>
    <version>0.4.20</version>
</dependency>



10. 13장(file)에 index.jsp 복사해서 15장에 upload 폴더에 write.jsp로 이름변경하여 붙여넣기



11.. write.jsp 작성
-----------------------------------------------------------
<jsp:include page="../layout/header.jsp">
  <jsp:param value="업로드게시글작성" name="title"/>
</jsp:include>

<div>

  <h1 style="text-align: center;">Upload 게시글 작성하기</h1>
  
  <form method="post" action="${contextPath}/upload/add.do" enctype="multipart/form-data">
    <div>
      <label for="email" class="form-label">작성자</label>
      <input type="text" id="email" class="form-control-plaintext" value="${sessionScope.user.email}" readonly>
    </div>
    <div>
      <label for="title" class="form-label">제목</label>
      <input type="text" name="title" id="title" class="form-control">
    </div>
    <div>
      <label for="contents" class="form-label">내용</label>
      <textarea rows="3" name="contents" id="contents" class="form-control"></textarea>
    </div>
    <div>
      <label for="files" class="form-label">첨부</label>
      <input type="file" name="files" id="files" class="form-control" multiple>
    </div>
    <div class="d-grid gap-2 col-6 mx-auto">
      <input type="hidden" name="userNo" value="${sessionScope.user.userNo}">
      <button type="submit" class="btn btn-primary" style="margin: 32px;">작성완료</button>
    </div>
  </form>
  
  <div id="file_list"></div>
  
</div>
  
<script>

  const fnFileCheck = () => {
    $('#files').change((ev) => {
      $('#file_list').empty();
      let maxSize = 1024 * 1024 * 100;
      let maxSizePerFile = 1024 * 1024 * 10;
      let totalSize = 0;
      let files = ev.target.files;
      for(let i = 0; i < files.length; i++){
        totalSize += files[i].size;
        if(files[i].size > maxSizePerFile){
          alert('각 첨부파일의 최대 크기는 10MB입니다.');
          $(ev.target).val('');
          $('#file_list').empty();
          return;
        }
        $('#file_list').append('<div>' + files[i].name + '</div>');
      }
      if(totalSize > maxSize){
        alert('전체 첨부파일의 최대 크기는 100MB입니다.');
        $(ev.target).val('');
        $('#file_list').empty();
        return;
      }
    })
  }
  
  fnFileCheck();
  
</script>
  
<%@ include file="../layout/footer.jsp" %>
----------------------------------------------


12. list.jsp 작성
-------------------------------------------------------
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn" %>
<c:set var="contextPath" value="${pageContext.request.contextPath}" />
<c:set var="dt" value="<%=System.currentTimeMillis()%>" />

<jsp:include page="../layout/header.jsp">
  <jsp:param value="업로드게시판" name="title"/>
</jsp:include>

<div>

  <div>
    <a href="${contextPath}/upload/write.form">
      <button type="button" class="btn btn-primary">새글작성</button>
    </a>
  </div>
  
  <div id="upload_list"></div>

</div>

<script>

</script>

<%@ include file="../layout/footer.jsp" %>
---------------------------------------------------


13. 컨트롤러 추가 작성
@RequestMapping("/upload")  // /upload 로 시작하는 것들은 다 컨트롤러로 온다.
@RequiredArgsConstructor
@Controller
public class UploadController {

  private final UploadService uploadService;  // 컨트롤러가 사용할 서비스
  
  @GetMapping("/list.do")
  public String list() {
    return "upload/list";
  }
  
  @GetMapping("/write.form")
  public String write() {
    return "upload/write";
  }
}



14. layout 폴더에 header.jsp 에 추가 작성
<li><a href="${contextPath}/upload/list.do">첨부게시판</a></li>


15. servlet-context.xml 에 추가 작성
<mapping path="/upload/write.form"/>



16. 매퍼.xml 작성
<insert id="insertUpload" parameterType="UploadDto">
    INSERT INTO UPLOAD_T (
        UPLOAD_NO
      , TITLE
      , CONTENTS
      , USER_NO
      , CREATED_AT
      , MODIFIED_AT
    ) VALUES (
        UPLOAD_SEQ.NEXTVAL
      , #{title}
      , #{contents}
      , #{userDto.userNo}
      , TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') 
      , TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') 
    )
  </insert>

  <insert id="insertAttach" parameterType="AttachDto">
    INSERT INTO ATTACH_T (
        ATTACH_NO
      , PATH
      , ORIGINAL_FILENAME
      , FILESYSTEM_NAME
      , DOWNLOAD_COUNT
      , HAS_THUMBNAIL
      , UPLOAD_NO
    ) VALUES (
        ATTACH_SEQ.NEXTVAL
      , #{path}
      , #{originalFilename}
      , #{filesystemName}
      , 0
      , #{hasThumbnail}
      , #{uploadNo}
    )
    
  </insert>
  

  
17. 매퍼.java 작성
@Mapper
public interface UploadMapper {
  public int insertUpload(UploadDto upload);
  public int insertAttach(AttachDto attach);
}


18. 서비스 작성
public interface UploadService {
  public int addUpload(MultipartHttpServletRequest request); // 파일첨부때문에 일반HttpServletRequest는 사용 못한다.
}


19. 서비스임플 작성
------------------------------------------
  @Override
  public boolean addUpload(MultipartHttpServletRequest multipartRequest) throws Exception {
    
    String title = multipartRequest.getParameter("title");
    String contents = multipartRequest.getParameter("contents");
    int userNo = Integer.parseInt(multipartRequest.getParameter("userNo"));
    
    UploadDto upload = UploadDto.builder()
                        .title(title)
                        .contents(contents)
                        .userDto(UserDto.builder()
                                  .userNo(userNo)
                                  .build())
                        .build();
                        
    int uploadCount = uploadMapper.insertUpload(upload);
    
    List<MultipartFile> files = multipartRequest.getFiles("files");     //첨부된 파일을 'MultipartFile' 이라고 부른다. multiple은 첨부파일이 여러개이기 때문에 List로 잡아야 한다.
    
    // 첨부 없을 때 : [MultipartFile[field="files", filename=, contentType=application/octet-stream, size=0]]
    // 첨부 1개 : [MultipartFile[field="files", filename="animal1.jpg", contentType=image.jpg size=0]]
    
    int attachCount;
    if(files.get(0).getSize() == 0) {   // 첨부가 없었으면,
      attachCount = 1;
    } else {
      attachCount = 0;
    }
    
    for(MultipartFile multipartFile : files) {
      
      if(multipartFile != null && !multipartFile.isEmpty()) {
        
        String path = myFileUtils.getUploadPath();
        File dir = new File(path);
        if(!dir.exists()) {
          dir.mkdirs();
        }
        
        String originalFilename = multipartFile.getOriginalFilename();
        String filesystemName = myFileUtils.getFilesystemName(originalFilename);  // 원래 이름에 확장자를 그대로 사용하기 위해 전달해주는 작업이 필요함.
        File file = new File(dir, filesystemName);
        
        multipartFile.transferTo(file);
        
        String contentType = Files.probeContentType(file.toPath()); // 이미지의 Content-Type : image/jpeg, image/png 등 image로 시작한다.
        int hasThumbnail = (contentType != null && contentType.startsWith("image")) ? 1 : 0; // null 체크가 필요하면 반드시 앞에 먼저 작성해준다.(contentType != null 가 이 구문과 같이 앞에 먼저 작성되어 있어야 한다는말)
        
        if(hasThumbnail == 1) {
          File thumbnail = new File(dir, "s_" + filesystemName); // small 이미지를 의미하는 s_을 덧붙임.
          Thumbnails.of(file)
                    .size(100,  100)
                    .toFile(thumbnail);
        }
      
        AttachDto attach = AttachDto.builder()
                             .path(path)
                             .originalFilename(originalFilename)
                             .filesystemName(filesystemName)
                             .hasThumbnail(hasThumbnail)
                             .uploadNo(upload.getUploadNo())
                             .build();
        
        attachCount += uploadMapper.insertAttach(attach);
        
      }  // if
      
    }    // for
    
    return (uploadCount == 1) && (files.size() == attachCount);   // 1이면 성공. attachCount와 파일사이즈가 같으면 성공. 
    
  }
------------------------------------------------------


20. MyFileUtils.java 추가 작성.
  // 업로드 게시판 작성시 첨부한 파일이 저장될 경로 반환하기
  public String getUploadPath() {
    LocalDate today = LocalDate.now();
    return "/upload/" + DateTimeFormatter.ofPattern("yyyy/MM/dd").format(today);
  }
  
  
  

21.서비스 수정
public interface UploadService {
  public int addUpload(MultipartHttpServletRequest request) throws Exception; // 파일첨부때문에 일반HttpServletRequest는 사용 못한다.
}




21. 컨트롤러 작성
  @PostMapping("/add.do")
  public String add(MultipartHttpServletRequest multipartRequest
                  , RedirectAttributes redirectAttributes) throws Exception {
    int addResult = uploadService.addUpload(multipartRequest);
    redirectAttributes.addFlashAttribute("addResult", addResult);
    return "redirect:/upload/list.do";
  }

  
  
22. 매퍼.xml 에 추가 작성 및 수정
  <insert id="insertUpload" parameterType="UploadDto">
    <!-- insert를 수행하기 전에 시퀀스 값을 파라미터 UploadDto의 uploadNo 필드에 UPLOAD_SEQ.NEXTVAL값을 저장한다. -->
    <selectKey order="BEFORE" resultType="int" keyProperty="uploadNo">
      SELECT UPLOAD_SEQ.NEXTVAL
        FROM DUAL
    </selectKey>
    INSERT INTO UPLOAD_T (
        UPLOAD_NO
      , TITLE
      , CONTENTS
      , USER_NO
      , CREATED_AT
      , MODIFIED_AT
    ) VALUES (
        #{uploadNo}
      , #{title}
      , #{contents}
      , #{userDto.userNo}
      , TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') 
      , TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') 
    )
  </insert>
  
====================================================================



[ 썸네일 만드는 코드와 썸네일있는지 여부 확인 ]


1. UploadServiceImpl (addUpload 메소드 안에 추가 작성)
----------------------------------------------------------
  @Override
  public boolean addUpload(MultipartHttpServletRequest multipartRequest) throws Exception {
    
    String title = multipartRequest.getParameter("title");
    String contents = multipartRequest.getParameter("contents");
    int userNo = Integer.parseInt(multipartRequest.getParameter("userNo"));
    
    UploadDto upload = UploadDto.builder()
                        .title(title)
                        .contents(contents)
                        .userDto(UserDto.builder()
                                  .userNo(userNo)
                                  .build())
                        .build();
                        
    int uploadCount = uploadMapper.insertUpload(upload);
    
    List<MultipartFile> files = multipartRequest.getFiles("files");     //첨부된 파일을 'MultipartFile' 이라고 부른다. multiple은 첨부파일이 여러개이기 때문에 List로 잡아야 한다.
    
    // 첨부 없을 때 : [MultipartFile[field="files", filename=, contentType=application/octet-stream, size=0]]
    // 첨부 1개 : [MultipartFile[field="files", filename="animal1.jpg", contentType=image.jpg size=0]]
    
    int attachCount;
    if(files.get(0).getSize() == 0) {   // 첨부가 없었으면,
      attachCount = 1;
    } else {
      attachCount = 0;
    }
    
    for(MultipartFile multipartFile : files) {
      
      if(multipartFile != null && !multipartFile.isEmpty()) {
        
        String path = myFileUtils.getUploadPath();
        File dir = new File(path);
        if(!dir.exists()) {
          dir.mkdirs();
        }
        
        String originalFilename = multipartFile.getOriginalFilename();
        String filesystemName = myFileUtils.getFilesystemName(originalFilename);  // 원래 이름에 확장자를 그대로 사용하기 위해 전달해주는 작업이 필요함.
        File file = new File(dir, filesystemName);
        
        multipartFile.transferTo(file);
        
        String contentType = Files.probeContentType(file.toPath()); // 이미지의 Content-Type : image/jpeg, image/png 등 image로 시작한다.
        int hasThumbnail = (contentType != null && contentType.startsWith("image")) ? 1 : 0; // null 체크가 필요하면 반드시 앞에 먼저 작성해준다.(contentType != null 가 이 구문과 같이 앞에 먼저 작성되어 있어야 한다는말)
        
        if(hasThumbnail == 1) {
          File thumbnail = new File(dir, "s_" + filesystemName); // small 이미지를 의미하는 s_을 덧붙임.
          Thumbnails.of(file)
                    .size(100,  100)
                    .toFile(thumbnail);
        }
      
        AttachDto attach = AttachDto.builder()
                             .path(path)
                             .originalFilename(originalFilename)
                             .filesystemName(filesystemName)
                             .hasThumbnail(hasThumbnail)
                             .uploadNo(userNo)
                             .build();
        
        attachCount += uploadMapper.insertAttach(attach);
        
      }  // if
      
    }    // for
    
    return (uploadCount == 1) && (files.size() == attachCount);   // 1이면 성공. attachCount와 파일사이즈가 같으면 성공. 
    
  }
-----------------------------------------------------------------


2. 서비스 수정 (타입을 boolean으로 수정)
public interface UploadService {
  public boolean addUpload(MultipartHttpServletRequest request) throws Exception; // 파일첨부때문에 일반HttpServletRequest는 사용 못한다.
}



3. 컨트롤러 수정
  @PostMapping("/add.do")
  public String add(MultipartHttpServletRequest multipartRequest
                  , RedirectAttributes redirectAttributes) throws Exception {
    boolean addResult = uploadService.addUpload(multipartRequest);
    redirectAttributes.addFlashAttribute("addResult", addResult);
    return "redirect:/upload/list.do";
  }
  


4. list.jsp 작성
<script>

	const fnAddResult = () => {
	  let addResult = '${addResult}';	// '', 'true', 'false'
	  if(addResult != ''){
		 if(addResult === 'true'){
			alert('성공적으로 업로드 되었습니다.');
			// 목록 갱신이 들어와야 하는 자리
		 } else {
		   alert('업로드가 실패하였습니다.');
		 }
	  }
	  
	}
	
	// 호출
	fnAddResult();

</script>


-----------------------------------------------------------------------




1. SQL 작성
------------------------------------------------------------------
-- 업로드 게시판 쿼리 테스트

-- 1. 업로드 목록 (업로드 - 첨부 조인, 업로드 - 사용자 조인)
--    첨부가 없는 업로드 게시글도 조회할 수 있도록 외부 조인을 사용함
--    작성자가 없는 업로드 게시글도 조회할 수 있도록 외부 조인을 사용함
SELECT UP.UPLOAD_NO, UP.TITLE, UP.CONTENTS, UP.CREATED_AT, UP.MODIFIED_AT, COUNT(ATC.ATTACH_NO) AS 첨부파일수, USR.USER_NO, USR.EMAIL, USR.NAME
  FROM UPLOAD_T UP LEFT OUTER JOIN ATTACH_T ATC 
    ON UP.UPLOAD_NO = ATC.UPLOAD_NO LEFT OUTER JOIN USER_T USR
    ON UP.USER_NO = USR.USER_NO
 GROUP BY UP.UPLOAD_NO, UP.TITLE, UP.CONTENTS, UP.CREATED_AT, UP.MODIFIED_AT, USR.USER_NO, USR.EMAIL, USR.NAME;
 
-- 첨부 테이블 정보를 조회하지 않는다면 업로드 - 첨부의 조인을 제거하고 작업을 수행할 수 있음
SELECT A.UPLOAD_NO, A.TITLE, A.CONTENTS, A.CREATED_AT, A.MODIFIED_AT, A.ATTACH_COUNT, A.USER_NO, A.EMAIL, A.NAME
  FROM (SELECT ROW_NUMBER() OVER(ORDER BY UPLOAD_NO DESC) AS RN,
                UP.UPLOAD_NO, UP.TITLE, UP.CONTENTS, UP.CREATED_AT, UP.MODIFIED_AT,
               (SELECT COUNT(*) FROM ATTACH_T ATC WHERE UP.UPLOAD_NO = ATC.UPLOAD_NO) AS ATTACH_COUNT,
                USR.USER_NO, USR.EMAIL, USR.NAME
                FROM UPLOAD_T UP LEFT OUTER JOIN USER_T USR
                  ON UP.USER_NO = USR.USER_NO) A
 WHERE A.RN BETWEEN 1 AND 9;
 -----------------------------------------------------------------


2. UploadMapper.xml 작성
  <select id="getUploadCount" resultType="int">
    SELECT COUNT(*)
      FROM UPLOAD_T
  </select>
  <!-- 최상단에서 UploadMap이 어떤 건지 쿼리문으로 설명해주었기 때문에 사용가능. -->
  <select id="getUploadList" parameterType="Map" resultMap="UploadMap">
    SELECT A.UPLOAD_NO, A.TITLE, A.CONTENTS, A.CREATED_AT, A.MODIFIED_AT, A.ATTACH_COUNT, A.USER_NO, A.EMAIL, A.NAME
      FROM (SELECT ROW_NUMBER() OVER(ORDER BY UPLOAD_NO DESC) AS RN,
                   UP.UPLOAD_NO, UP.TITLE, UP.CONTENTS, UP.CREATED_AT, UP.MODIFIED_AT,
                   (SELECT COUNT(*) FROM ATTACH_T ATC WHERE UP.UPLOAD_NO = ATC.UPLOAD_NO) AS ATTACH_COUNT,
                   USR.USER_NO, USR.EMAIL, USR.NAME
              FROM UPLOAD_T UP LEFT OUTER JOIN USER_T USR
                ON UP.USER_NO = USR.USER_NO) A
     WHERE A.RN BETWEEN #{begin} AND #{end}
  </select>
  

+ 상단에 매퍼태그 밑에 바로 적어줄 것
----------------------------------------------------------
<mapper namespace="com.gdu.myhome.dao.UploadMapper">

  <!-- UploadDto에는 UserDto가 포함되어 있으므로 resultMap을 만들어서 UploadDto의 설명을 넣어준다. -->
  <resultMap type="UploadDto"       id="UploadMap">         <!-- 최종적으로 UploadMap으로 부르기로 함. -->
    <id      column="UPLOAD_NO"     property="uploadNo"/>
    <result  column="TITLE"         property="title"/>
    <result  column="CONTENTS"      property="contents"/>
    <result  column="CREATED_AT"    property="createdAt"/>
    <result  column="MODIFIED_AT"   property="modifiedAt"/>
    <result  column="ATTACH_COUNT"  property="attachCount"/>
    <association javaType="UserDto"      property="userDto">
      <id        column="USER_NO"        property="userNo"/>
      <result    column="EMAIL"          property="email" />
      <result    column="PW"             property="pw" />
      <result    column="NAME"           property="name" />
      <result    column="GENDER"         property="gender" />
      <result    column="MOBILE"         property="mobile" />
      <result    column="POSTCODE"       property="postcode" />
      <result    column="ROAD_ADDRESS"   property="roadAddress" />
      <result    column="JIBUN_ADDRESS"  property="jibunAddress" />
      <result    column="DETAIL_ADDRESS" property="detailAddress" />
      <result    column="AGREE"          property="agree" />
      <result    column="STATE"          property="state" />
      <result    column="PW_MODIFIED_AT" property="pwModifiedAt" />
      <result    column="JOINED_AT"      property="joinedAt" />
    </association>
  </resultMap>
  
  
------------------------------------------------------------------------




3. UploadDto 추가 작성
private int attachCount;    // UPLOAD_T에는 없는 칼럼이지만, 목록 보기에서 첨부파일갯수를 반환하므로 그 결과를 저장하기 위해서 추가함

*Dto안에 Dto가 들어있으면 Mapper가 인식하지 못한다.(우리만 아는 정보이다)




4. UploadMapper.java 작성
public int getUploadCount();
public List<UploadDto> getUploadList(Map<String, Object> map);  // 매퍼.xml 에서는 UploadMap 으로 적었지만, 자바가 인식하기는 UploadDto로 인식한다.




5. 서비스 작성
 public Map<String, Object> getUploadList(HttpServletRequest request); // 목록을 ajax으로 넘길 때는 Map을 가장 많이 쓴다. (목록을 안 쓴다면 List도 가능하지만, 확장때문에 Map을 쓴다. Map을 쓰면 목록 외에 다른 것도 담을 수 있기 때문에 확장성에 좋다.)
  // ↑ 컨트롤러로부터 page 번호를 받아온다. (하나만 쓰려면 int page를 써도 되지만, 그 외에도 여러가지를 저장하고 담으려면 HttpServletRequest를 써야 한다.  HttpServletRequest가 여러가지를 담는 확장성이 좋다.)




6. 서비스임플 작성
  @Transactional(readOnly=true)
  @Override
  public Map<String, Object> getUploadList(HttpServletRequest request) {

    Optional<String> opt = Optional.ofNullable(request.getParameter("page"));
    int page = Integer.parseInt(opt.orElse("1"));
    int total = uploadMapper.getUploadCount();
    int display = 9;
    
    myPageUtils.setPaging(page, total, display);
    
    Map<String, Object> map = Map.of("begin", myPageUtils.getBegin()
                                   , "end", myPageUtils.getEnd());
    
    List<UploadDto> uploadList = uploadMapper.getUploadList(map);
    
    return Map.of("uploadList", uploadList
                , "totalPage", myPageUtils.getTotalPage());
    
  }
  
  
  

7. 컨트롤러 작성
  @ResponseBody
  @GetMapping(value="/getList.do", produces="application/json")
  public Map<String, Object> getList(HttpServletRequest request) {  // HttpServletRequest를 최초 선언해서 사용할 수 있는 게 컨트롤러이다.
    return uploadService.getUploadList(request);
  }




8. list.jsp 수정 및 작성
-------------------------------------------------------------------------------------
<div id="upload_list" class="upload_list"></div>

</div>

<script>
	
	// 전역 변수
	var page = 1;
	var totalPage = 0;
	
	const fnGetUploadList = () => {
	  $.ajax({
		  // 요청
		  type: 'get',
		  url: '${contextPath}/upload/getList.do',
		  data: 'page=' + page,
		  // 응답
		  dataType: 'json',
		  success: (resData) => {  // resData = {"uploadList": [], "totalPage": 10}
			  totalPage = resData.totalPage;
		    $.each(resData.uploadList, (i, upload) => {
		    	let str = '<div class="upload">';
		    	str += '<div>제목: ' + upload.title + '</div>';
		    	str += '<div>작성: ' + upload.userDto.name + '</div>'; // 작성자는 userDto에 있는 name
		    	str += '<div>생성: ' + upload.createdAt + '</div>';    // 작성일자
		    	str += '<div>첨부: ' + upload.attachCount + '개</div>';
		    	str += '</div>';
		    	$('#upload_list').append(str);
		    })
		  }
	  })
  }


    const fnScroll = () => {
		
	  var timerId;	// 최초 undefined 상태.
	  
	  $(window).on('scroll', () => {	// window 객체가 스크롤을 관장한다.  윈도우가 스크롤 되었을 때.
	
		if(timerId){	// timerId가 undefined이면 false로 인식, timerId가 값을 가지면 true로 인식
	      clearTimeout(timerId);	
		}  
		  
		timerId = setTimeout(() => {  // setTimeout 실행 전에는 timerId가 undefined 상태, setTimeout이 한 번이라도 동작하면 timerId가 값을 가짐.
		  
		 // 반드시 작성해야 하는 3가지 ↓
		  let scrollTop = $(window).scrollTop();  // 스크롤바 위치(스크롤 된 길이)	   // ← 이 줄부터 내가 하고 싶은 일 적으면 된다.
		  let windowHeight = $(window).height();  // 화면 전체 크기
		  let documentHeight = $(document).height();  // 문서 전체 크기
		  
		  if((scrollTop + windowHeight + 100) >= documentHeight) {   // 스크롤이 바닥에 닿기 50px 전에 true가 됨.
			if(page > totalPage) {  // 마지막 페이지를 보여준 이후에 true가 됨.
			  return;   // 마지막 페이지를 보여준 이후에는 아래 코드를 수행하지 말 것 (return의 의미 : return 이후의 코드를 수행하지 마라)
			}
		  	page++;  // 다음페이지로 넘어감.
		  	fnGetUploadList();	// 다음페이지 목록 갱신
		  }
		  
		}, 200);	// 200밀리초(0.2초) 후 동작
		
	  })
	  
	}
	



	const fnAddResult = () => {
	  let addResult = '${addResult}';	// '', 'true', 'false'
	  if(addResult != ''){
		 if(addResult === 'true'){
			alert('성공적으로 업로드 되었습니다.');
			$('#upload_list').empty();
		 } else {
		   alert('업로드가 실패하였습니다.');
		 }
	  }
	  
	}
	
	// 호출
	fnGetUploadList();
	fnScroll();
	fnAddResult();


------------------ 최상단에 스타일 추가 ----------------------------
<!-- "내용물만 200이다." 라고 지정하는 방식은 box-sizing: content-box: 이고, "전체 박스크기가 200이다." 라고 하려면 box-sizing: border-box: 로 한다. -->
<!-- margin: 상하여백10px 좌우는auto -->
<!-- 기본 flex는 한 줄에 9개씩 빼곡하게 찬다. 기본값은 flex-wrap:nowrap: 이다. (크기 무시하고 우겨넣음), 그러지 말라고 flex-wrap:wrap: 으로 바꿔주어야 크기 모자르면 다음으로 넘어간다. -->
<!-- padding-top: 100px;  => 상단 여백 100px -->
<!-- margin: 위아래20px, 좌우 15px -->
<style>
  div {
    box-sizing: border-box;
  }
  .upload_list {
    width: 1000px;
    margin: 10px auto;  
    display: flex;
    flex-wrap: wrap;
  }
  .upload {
    width: 300px;
    height: 300px;
    border: 1px solid gray;
    text-align: center;
    padding-top: 100px;
    margin: 20px 15px;
  }
  .upload:hover {
    background-color: silver
    cursor: pointer;
  }
</style>
--------------------------------------------------------------------



=======================첨부형 게시판 이어서 작성=============================

1. 매퍼.xml 작성
  <select id="getUpload" parameterType="int" resultMap="UploadMap">  <!-- result는 리턴하는 타입:반환타입 -->
    SELECT UP.UPLOAD_NO, UP.TITLE, UP.CONTENTS, UP.CREATED_AT, UP.MODIFIED_AT
         , USR.USER_NO, USR.EMAIL, USR.NAME
      FROM USER_T USR RIGHT OUTER JOIN UPLOAD_T UP
        ON USR.USER_NO = UP.USER_NO
     WHERE UPLOAD_NO = #{uploadNo}
  </select>
  
  <select id="getAttachList" parameterType="int" resultType="AttachDto">
    SELECT ATTACH_NO, PATH, ORIGINAL_FILENAME, FILESYSTEM_NAME, DOWNLOAD_COUNT, HAS_THUMBNAIL, UPLOAD_NO
      FROM ATTACH_T
     WHERE UPLOAD_NO = #{uploadNo}
  </select>
  
  
  
2. 매퍼.java 작성
  public UploadDto getUpload(int uploadNo);
  public List<AttachDto> getAttachList(int uploadNo);
  
  
  
3. 서비스 작성
public void loadUpload(HttpServletRequest request, Model model);


4. 서비스 임플 작성
  @Transactional(readOnly=true)
  @Override
  public void loadUpload(HttpServletRequest request, Model model) {
    
    Optional<String> opt = Optional.ofNullable(request.getParameter("uploadNo"));
    int uploadNo = Integer.parseInt(opt.orElse("0"));  // uploadNo는 정수변환이 필요하니까 파스인트쓰고, 전달이 안됐을 때는 0을 사용한다.
    
    model.addAttribute("upload", uploadMapper.getUpload(uploadNo));
    model.addAttribute("attachList", uploadMapper.getAttachList(uploadNo));
    
  }
  


5. 컨트롤러 작성
  @GetMapping("/detail.do")
  public String detail(HttpServletRequest request, Model model) {
    uploadService.loadUpload(request, model);
    return "upload/detail";   // 업로드폴더에 detail.jsp로 가겠다.
  }



6. detail.jsp 만들기
<jsp:include page="../layout/header.jsp">
  <jsp:param value="${upload.uploadNO}번 게시글" name="title"/>
</jsp:include>

<style>
  .attach {
    cursor: pointer;
  }
</style>

<div>

  <h1 style="text-align: center;">Upload 게시글</h1>
  <div>작성자 : ${upload.userDto.name}</div>
  <div>작성일 : ${upload.createdAt}</div>
  <div>수정일 : ${upload.modifiedAt}</div>
  <div>제목 : ${upload.title}</div>
  <div>내용</div>
  <div>${upload.contents}</div>
  <div>
    <form id="frm_btn" method="post">   <!-- 버튼을 모아두는 폼 -->
      <input type="hidden" name="uploadNo" value="${upload.uploadNO}">
      <button type="button" id="btn_edit">편집</button>
      <button type="button" id="btn_remove">삭제</button>
    </form>
  </div>
  
  <div id="file_list"></div>
  
  <h4>첨부 다운로드</h4>
  <div>
    <c:if test="${empty attachList}">  <!-- empty attachList : 첨부가 없을 때. -->
      <div>첨부 없음</div>
    </c:if>
    <c:if test="${not empty attachList}">  <!-- empty attachList : 첨부가 있을 때. -->
      <c:forEach items="${attachList}" var="atc">
        <div class="attach" data-attach_no="${atc.attachNo}">
            <c:if test="${atc.hasThumbnail == 1}">   <!-- 썸네일 있으면 1 -->
            <img src="${contextPath}${atc.path}/s_${atc.filesystemName}" alt="썸네일" width="50px">
          </c:if>
          <c:if test="${atc.hasThumbnail == 0}">     <!-- 썸네일 없으면 0 -->
            <img src="${contextPath}/resources/image/attach1.png" alt="썸네일" width="50px">
          </c:if>
          ${atc.originalFilename}   <!-- 첨부된 파일들의 원래 이름 -->
        </div>
      </c:forEach>
      <div><a href="${contextPath}/upload/downloadAll.do?uploadNo=${upload.uploadNo}">모두 다운로드</a></div>
    </c:if>
  </div>
  
</div>
  
<script>

  const fnDownload = () => {
	  $('.attach').click(function(){
		  if(confirm('다운로드 할까요?')){
			  location.href = '${contextPath}/upload/download.do?attachNo=' + $(this).data('attach_no');
		  }
	  })
  }
  
  fnDownload();
  
</script>
  
<%@ include file="../layout/footer.jsp" %>




7. servlet-context.xml 추가 작성
  <!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory -->
  <resources mapping="/resources/**" location="/resources/" />
  <resources mapping="/blog/**" location="file:///blog/" />   
  <resources mapping="/upload/**" location="file:///upload/" />  <-- 이것 추가 : 업로드 경로 매핑 추가해주기.




8. 매퍼.xml 작성
  <select id="getAttach" parameterType="int" resultType="AttachDto">
    SELECT ATTACH_NO, PATH, ORIGINAL_FILENAME, FILESYSTEM_NAME, DOWNLOAD_COUNT, HAS_THUMBNAIL, UPLOAD_NO
      FROM ATTACH_T
     WHERE ATTACH_NO = #{attachNo}
  </select>
  
  <update id="updateDownloadCount" parameterType="int">
    UPDATE ATTACH_T
       SET DOWNLOAD_COUNT = DOWNLOAD_COUNT + 1
     WHERE ATTACH_NO = #{attachNo}
  </update>




9. 매퍼.java 작성
  public AttachDto getAttach(int attachNo);
  public int updateDownloadCount(int attachNo);
  
  
  

10. list.jsp 기존 것 수정
---------------------------------------------
const fnGetUploadList = () => {
		  $.ajax({
			  // 요청
			  type: 'get',
			  url: '${contextPath}/upload/getList.do',
			  data: 'page=' + page,
			  // 응답
			  dataType: 'json',
			  success: (resData) => {  // resData = {"uploadList": [], "totalPage": 10}
				  totalPage = resData.totalPage;
			    $.each(resData.uploadList, (i, upload) => {
			    	let str = '<div class="upload" data-upload_no="' + upload.uploadNo + '">';
			    	str += '<div>제목: ' + upload.title + '</div>';
			    	if(upload.userDto === null){
			    	  str += '<div>작성: 정보없음</div>';
			    	} else {
			    	str += '<div>작성: ' + upload.userDto.name + '</div>'; // 작성자는 userDto에 있는 name
			    	}
			    	str += '<div>생성: ' + upload.createdAt + '</div>';    // 작성일자
			    	str += '<div>첨부: ' + upload.attachCount + '개</div>';
			    	str += '</div>';
			    	$('#upload_list').append(str);
			    })
			  }
		  })
	  }
---------------------------------------------
 
 
  
11. 서비스 작성
public ResponseEntity<Resource> download(HttpServletRequest request); // ResponseEntity 가 요청헤더도 담당해서, HttpServletResponse 역할도 같이 담당한다.



12. 서비스임플 작성
--------------------------------------------
  @Override
  public ResponseEntity<Resource> download(HttpServletRequest request) {
    
    // 첨부 파일의 정보 가져오기
    int attachNo = Integer.parseInt(request.getParameter("attachNo"));
    AttachDto attach = uploadMapper.getAttach(attachNo);
    
    // 첨부 파일 File 객체 -> Resource 객체
    File file = new File(attach.getPath(), attach.getFilesystemName());
    Resource resource = new FileSystemResource(file);  // 리소스화 시킴.
    
    // 첨부 파일이 없으면 다운로드 취소
    if(!resource.exists()) {
      return new ResponseEntity<Resource>(HttpStatus.NOT_FOUND);
    }
    
    // 다운로드 횟수 증가하기
    uploadMapper.updateDownloadCount(attachNo);
    
    // 사용자가 다운로드 받을 파일의 이름 결정 (User-Agent값에 따른 인코딩 처리)
    String originalFilename = attach.getOriginalFilename();
    String userAgent = request.getHeader("User-Agent");  // getHeader : request header라고 해서 요청헤더이다.
    try {
      // IE
      if(userAgent.contains("Trident")) {
        originalFilename = URLEncoder.encode(originalFilename, "UTF-8").replace("+", " ");
      }
      // Edge
      else if(userAgent.contains("Edg")) {
        originalFilename = URLEncoder.encode(originalFilename, "UTF-8");
      }
      // Other
      else {
        originalFilename = new String(originalFilename.getBytes("UTF-8"), "ISO-8859-1");
      }
    } catch(Exception e) {
      e.printStackTrace();
    }
    
    // 다운로드 응답 헤더 만들기
    HttpHeaders header = new HttpHeaders();  // 자동완성 스프링프레임워크로 선택해야함.
    header.add("Content-Type", "application/octet-stream");
    header.add("Content-Disposition", "attachment; filename=" + originalFilename);
    header.add("Content-Length", file.length() + "");  // 빈문자열을 더해서 String으로 바꿔준다.
    
    // 응답
    return new ResponseEntity<Resource>(resource, header, HttpStatus.OK);
    
  }
---------------------------------------------



13. 컨트롤러 작성
  @GetMapping("/download.do")
  public ResponseEntity<Resource> download(HttpServletRequest request) {
    return uploadService.download(request);
  }



14. 서비스 작성
public ResponseEntity<Resource> downloadAll(HttpServletRequest request);



15. MyFileUtils.java 추가 작성
// 업로드 게시판 작성시 첨부한 파일이 저장될 경로 반환하기
  public String getUploadPath() {
    LocalDate today = LocalDate.now();
    return "/upload/" + DateTimeFormatter.ofPattern("yyyy/MM/dd").format(today);
  }
  
  (밑에꺼 추가 ↓)
  // 임시 파일이 저장될 경로 반환하기 (zip 파일)
  public String getTempPath() {
    return "/temp";
  }


-------------하단에도 추가 작성------------------
  return UUID.randomUUID().toString().toString().replace("-", "") + "." + extName; // ← 원래 이름과 저장된 이름 구성하기.
  }
     ( 밑에 것 추가 ↓ )
  
  // 임시 파일 이름 반환하기 (확장자는 제외하고 이름만 반환)
  public String getTempFilename() {
    return System.currentTimeMillis() + "";
  }





16.서비스임플 작성
  @Override
  public ResponseEntity<Resource> downloadAll(HttpServletRequest request) {
    
    // 다운로드 할 모든 첨부 파일 정보 가져오기
    int uploadNo = Integer.parseInt(request.getParameter("uploadNo"));
    List<AttachDto> attachList = uploadMapper.getAttachList(uploadNo);
    
    // 첨부 파일이 없으면 종료
    if(attachList.isEmpty()) {
      return new ResponseEntity<Resource>(HttpStatus.NOT_FOUND);
    }
    
    // zip 파일을 생성할 경로
    File tempDir = new File(myFileUtils.getTempPath());
    if(!tempDir.exists()) {
      tempDir.mkdirs();
    }
    
    // zip 파일의 이름
    String zipName = myFileUtils.getTempFilename() + ".zip";
    
    // zip 파일의 File 객체
    File zipFile = new File(tempDir, zipName);
    
    // zip 파일을 생성하는 출력 스트림
    ZipOutputStream zout = null;
    
    // 첨부 파일들을 순회하면서 zip 파일에 등록하기
    try {
      
      zout = new ZipOutputStream(new FileOutputStream(zipFile));
      
      for(AttachDto attach : attachList) {
        
        // 각 첨부 파일들의 원래 이름으로 zip 파일에 등록하기 (이름만 등록)
        ZipEntry zipEntry = new ZipEntry(attach.getOriginalFilename());
        zout.putNextEntry(zipEntry);
        
        // 각 첨부 파일들의 내용을 zip 파일에 등록하기 (실제 파일 등록)
        BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(attach.getPath(), attach.getFilesystemName())));
        zout.write(bin.readAllBytes());
        
        // 자원 반납
        bin.close();
        zout.closeEntry();
        
        // 다운로드 횟수 증가
        uploadMapper.updateDownloadCount(attach.getAttachNo());
        
      }
      
      // zout 자원 반납
      zout.close();
      
    } catch (Exception e) {
      e.printStackTrace();
    }
    
    // 다운로드할 zip 파일의 File 객체 -> Resource 객체
    Resource resource = new FileSystemResource(zipFile);
    
    // 다운로드 응답 헤더 만들기
    HttpHeaders header = new HttpHeaders();
    header.add("Content-Type", "application/octet-stream");
    header.add("Content-Disposition", "attachment; filename=" + zipName);
    header.add("Content-Length", zipFile.length() + "");
    
    // 응답
    return new ResponseEntity<Resource>(resource, header, HttpStatus.OK);
    
  }



17. 컨트롤러 작성
  @GetMapping("/downloadAll.do")
  public ResponseEntity<Resource> downloadAll(HttpServletRequest request) {
   return uploadService.downloadAll(request); 
  }





18. list.jsp 추가 작성 ( 글 상세보기 )
<script>

  const fnDownload = () => {
	  $('.attach').click(function(){
		  if(confirm('다운로드 할까요?')){
			  location.href = '${contextPath}/upload/download.do?attachNo=' + $(this).data('attach_no');
		  }
	  })
  }
  
  fnDownload();
  
</script>


=========임시파일 삭제하기===========


1.서비스 작성
public void removeTempFiles();



2.서비스임플 작성
@Override
  public void removeTempFiles() {
    File tempDir = new File(myFileUtils.getTempPath());
    File[] targetList = tempDir.listFiles();
    if(targetList != null) {
      for(File target : targetList) {
        target.delete();
      }
    }
  }




3. 스케쥴 패키지에 RemoveTempFileBatch 클래스 만들기.
@RequiredArgsConstructor
@Component
public class RemoveTempFileBatch {

  private final UploadService uploadService;
  
  @Scheduled(cron="0 15 16 * * ?")
  public void execute() {
    uploadService.removeTempFiles();
  }

==========================================



------블로그 패키지와 블로그views폴더에 수정할 부분 ↓↓↓ -----------

1. detail.jsp 수정



2. BlogController 수정
  @PostMapping("/edit.form")
  public String edit(@ModelAttribute("blog") BlogDto blog) {  // Model 에 실어줄 때, blog라는 이름으로 실어줄 수 있도록 이름을 바꿔주는 ModelAttribute를 사용한다.
    return "blog/edit";  // edit.jsp 에 가서 블로그 편집을 하겠다.
  }
  
------------------------------------------------------------------







