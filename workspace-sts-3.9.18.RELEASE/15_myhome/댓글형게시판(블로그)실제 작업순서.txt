< 댓글형 게시판 작업 >

[ 블로그 작업 ]

1. UserDto 와 InactiveUserDto 작성
private int state; 추가


2. BlogDto 만들어서 작성.
@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder		// 쉬운 생성을 도와주는 빌더패턴
public class BlogDto {
  private int blogNo;
  private String title;
  private String contents;
  private int userNo;
  private int hit;
  private String ip;
  private String createdAt;
  private String modifiedAt;
}


3. CommentDto 만들어서 작성.
@NoArgsConstructorㅒ
@AllArgsConstructor
@Data
@Builder		// 쉬운 생성을 도와주는 빌더패턴
public class CommentDto {
  private int commentNo;
  private String contents;
  private int userNo;
  private int blogNo;
  private String createdAt;
  private int status;
  private int depth;
  private int groupNo;
}


4.  Dto의 원래 타입이름이 길기 때문에(패키지 이름으로 나옴) mybatis-config.xml 에 가서 별명 만들기.
<typeAlias alias="BlogDto" type="com.gdu.myhome.dto.BlogDto"/>
<typeAlias alias="CommentDto" type="com.gdu.myhome.dto.CommentDto"/>


--------------------------------------------------
[ 파일 첨부 기능 ]

< ===================파일 첨부를 위한 사전작업과============================
=====================새 글 작성시 이미지 첨부하는 기능 =================>

< 블로그 작성시 첨부한 이미지가 작성 후에도 저장되게 하기 >

1. pom.xml에 파일첨부 넣기 (나는 이미 pom에 들어가있음, 추가 X)
 <!-- 파일 첨부(commons-io + commons-fileupload) -->
    <!-- https://mvnrepository.com/artifact/commons-io/commons-io -->
    <dependency>
      <groupId>commons-io</groupId>
      <artifactId>commons-io</artifactId>
      <version>2.8.0</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload -->
    <dependency>
      <groupId>commons-fileupload</groupId>
      <artifactId>commons-fileupload</artifactId>
      <version>1.5</version>
    </dependency>


2. FileConfig.java 작성
@Configuration
public class FileConfig {

  // MultipartResolver 라는 빈이 없으면 파일첨부가 불가능하다.
  @Bean
  public MultipartResolver multipartResolver() {  // 항상 인터페이스가 있으면 인터페이스 타입으로 잡기.
    CommonsMultipartResolver commonsMultipartResolver = new CommonsMultipartResolver();
    commonsMultipartResolver.setDefaultEncoding("UTF-8");
    commonsMultipartResolver.setMaxUploadSize(1024 * 1024 * 100); // 전체 첨부 파일의 크기 100메가 = 1mg x 1mg x 100 : 100메가.
    commonsMultipartResolver.setMaxUploadSizePerFile(1024 * 1024 * 10); // 개별 첨부 파일의 최대 크기 10메가 = 1mg x 1mg x 10 :  10메가.
    return commonsMultipartResolver;
  }
  
}


3. MyFileUtils.java 작성
@Component
public class MyFileUtils {   // @Component 해놓고 불러다가 @Autowired 로 쓸 것.

  // 블로그 작성시 사용된 이미지가 저장될 경로 반환하기
  public String getBlogImagePath() {
    /*  /storage/yyyy/MM/dd */
    LocalDate today = LocalDate.now();  // 오늘을 구하는 방법
   return "/blog/" + DateTimeFormatter.ofPattern("yyyy/MM/DD").format(today);
  }
  
  // 파일이 저장될 이름 반환하기 (파일을 올릴 때 이름과, 실제 저장될 때 이름은 다르다)
  public String getFilesystemName(String originalFileName) { // Filesystem 은 한 단어임.
    
    /*  UUID.확장자  */
    
    String extName = null;
    if(originalFileName.endsWith("tar.gz")) { // 확장자에 마침표가 포함되는 예외 경우를 처리한다.
      extName = "tar.gz";
    } else {                                    // 자동완성시 regex 있으면 정규식 입력하라는 의미. 정규식에서 '.' 는 모든 문자라는 성격을 가지고 있음.
      String[] arr = originalFileName.split("\\.");  // 마침표를 문자로 만들어주려면, [.] 또는 \\. 으로 입력.
      extName = arr[arr.length-1];
    }   
    //   ↑↑↑ 확장자 만드는 식
    
    return UUID.randomUUID().toString().toString().replace("-", "") + "." + extName; // ← 원래 이름과 저장된 이름 구성하기.
  }

--------------------------------------------------
  
< 블로그 작업 이어서 >
  
5. header.jsp 작성
<li><a href="${contextPath}/blog/list.do">댓글형게시판</a></li>



6. BlogController 만들기
@RequestMapping("/blog")
@Controller
public class BlogController {

  @GetMapping("/list.do")
  public String list(HttpServletRequest request, Model model) {
    return "blog/list";
  }
  
}



7. view에 blog폴더 만들고 list.jsp 작성
<div>
  <a href="${contextPath}/blog/write.form">
    <button type="button" class="btn btn-primary">새글작성</button>
  </a>
</div>



8. blogController 이어서 작성
@GetMapping("/list.do")
  public String list(HttpServletRequest request, Model model) {
    return "blog/list";
  }
  
  @GetMapping("/write.form")
  public String write() {
    return "blog/write";
  }



9. write.jsp 작성
------------------------------------------------------
<jsp:include page="../layout/header.jsp">
  <jsp:param value="블로그작성" name="title"/>
</jsp:include>

<style>
  .ck.ck-editor {
    max-width: 800px;
  }
  .ck-editor__editable {
    min-height: 400px;
  }
  .ck-content {
    color: gray;
  }
</style>

<div>
    <!-- form id="frm_blog_add"는 title의 공백을 검사할 때 사용한다.(지금은 사용 안한 버젼 -->
  <form id="frm_blog_add" method="post" action="${contextPath}/blog/addBlog.do">
    
    <h1>블로그를 작성하세요</h1>
    
    <div>
      <label for="title">제목</label>
      <input type="text" name="title" id="title">
    </div>
    
    <div>
      <label for="contents">내용</label>
      <textarea name="contents" id="contents"></textarea>
    </div>
    
    <div>
      <input type="hidden" name="userNo" value="${sessionScope.user.userNo}"> <!-- 세션에 있는 유저에 있는 유저넘버 -->
      <button type="submit">작성완료</button>
    </div>
    
  </form>

  <script>
    const fnCkeditor = () => {		// 화살표 함수로 변수로 전달하는 방식
  		 
  	  ClassicEditor
  	    .create(document.getElementById('contents'), {	//	getElementById('?')  <- 물음표 자리는 상황에 따라 이름을 바꿔서 써야 한다. 
  		    toolbar: {
  			    items: [
  		        'undo', 'redo',
  		        '|', 'heading',
  		        '|', 'fontfamily', 'fontsize', 'fontColor', 'fontBackgroundColor',
  		        '|', 'bold', 'italic', 'strikethrough', 'subscript', 'superscript', 'code',
  		        '|', 'link', 'uploadImage', 'blockQuote', 'codeBlock',
  		        '|', 'bulletedList', 'numberedList', 'todoList', 'outdent', 'indent'
    		    ],
    		    shouldNotGroupWhenFull: false
    	   },
         heading: {
           options: [
             { model: 'paragraph', title: 'Paragraph', class: 'ck-heading_paragraph' },
             { model: 'heading1', view: 'h1', title: 'Heading 1', class: 'ck-heading_heading1' },
             { model: 'heading2', view: 'h2', title: 'Heading 2', class: 'ck-heading_heading2' },
             { model: 'heading3', view: 'h3', title: 'Heading 3', class: 'ck-heading_heading3' },
             { model: 'heading4', view: 'h4', title: 'Heading 4', class: 'ck-heading_heading4' },
             { model: 'heading5', view: 'h5', title: 'Heading 5', class: 'ck-heading_heading5' },
             { model: 'heading6', view: 'h6', title: 'Heading 6', class: 'ck-heading_heading6' }
           ]
         },
         ckfinder: {
      	   // 업로드 경로 (블로그 경로로 이미지 업로드를 하겠다.)
      	   uploadUrl: '${contextPath}/blog/imageUpload.do'
         }
  	   })
  	   .catch(err => {
  		   console.log(err)
  	   });
  	  
    }
    
    // 함수 호출
    fnCkeditor();
    
  </script>

</div>

<%@ include file="../layout/footer.jsp" %>
----------------------------------------------


10. servlet-context.xml 작성
<interceptor>
  <mapping path="/user/mypage.form"/>
  <mapping path="/user/modifyPw.form"/>
  <mapping path="/free/write.form"/>
  <mapping path="/blog/write.form"/>	<-- 이걸 추가 (로그인 되어있는지 검사)
  <beans:bean class="com.gdu.myhome.intercept.RequiredLoginInterceptor" />  <!-- 필수 로그인 인터셉터 : RequiredLoginInterceptor -->
</interceptor>


11. BlogService 인터페이스와 BlogServiceImpl.java(BlogService 인터페이스 추가) 만들기.

12. BlogController에 작성
private final BlogService blogService;

그리고 클래스 상단에 @RequiredArgsConstructor 붙이기.

추가 작성 :
// produces 가 있으면, 무조건 @ResponseBody 가 붙는다 (ajax처럼 동작하기 때문) 
  // 첨부 파일 관련된 것은 전부 다 POST 다. (주소창에 파일 못 붙임)
  // json을 반환할 때 최적화된 것 : Map
  @ResponseBody
  @PostMapping(value="/imageUpload.do", produces="application/json") // value만 작성할 때는 value를 생략할 수 있지만, 또 적을 게 있다면 value를 꼭 적어주어야 함.
  public Map<String, Object> imageUpload(MultipartHttpServletRequest multipartRequest) {   // MultipartHttpServletRequest : 파일을 받을 수 있는 MultipartHttpServletRequest 
    return blogService.imageUpload(multipartRequest);
  }
  
  
13. BlogService 작성
public interface BlogService {
  public Map<String, Object> imageUpload(MultipartHttpServletRequest multipartRequest);
}


14.BlogServiceImpl 작성
--------------------------------------------------------------- 
@RequiredArgsConstructor
@Service
public class BlogServiceImpl implements BlogService {
  
  private final MyFileUtils myFileUtils;
  
  @Override
  public Map<String, Object> imageUpload(MultipartHttpServletRequest multipartRequest) {
   
    // 이미지가 저장될 경로
    String imagePath = myFileUtils.getBlogImagePath();
    File dir = new File(imagePath);
    if(!dir.exists()) {
      dir.mkdirs();
    }
    
    // 이미지 파일 (CKEditor는 이미지를 upload 라는 이름으로 보냄)
    MultipartFile upload = multipartRequest.getFile("upload");
    
    // 이미지가 저장될 이름
    String originalFilename = upload.getOriginalFilename();
    String filesystemName = myFileUtils.getFilesystemName(originalFilename);  // 저장될 이름을 제공한다.
    
    // 이미지 File 객체
    File file = new File(dir, filesystemName);   // 경로는 dir , 저장된 이름은 filesystemName
    
    // 저장
    try {
      upload.transferTo(file);  // file을 보내라.
    } catch (Exception e) {
      e.printStackTrace();
    }
    
    // CKEditor로 저장된 이미지의 경로를 JSON 형식으로 반환해야 함
    return Map.of("uploaded", true  // 업로드 되었다, 그렇다.
                , "url", multipartRequest.getContextPath() + imagePath + "/" + filesystemName);  // 이미지가 저장될 경로. 
  
    // url: "http://localhost:8080/myhome/blog/2023/10/27/파일명"  <- CKEditor로 이 주소를 보냈다.
    // servlet-context.xml에
    // /blog/** 주소 요청을 실제 저장될 디렉토리인  /blog 디렉터리로 연결하는 <resources> 태그를 추가해야 함.
  
  }
--------------------------------------------------------------- 


15. servlet-context.xml에 작성
<!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory -->
 <resources mapping="/resources/**" location="/resources/" />
 <resources mapping="/blog/**" location="file:///blog/" />   <!-- file:// 를 붙이면 프로젝트 내부 폴더가 아닌, 외부 폴더 경로로 인식한다. --> 

===================여기까지 새 글 작성시 이미지 첨부하는 기능============================
 
< 블로그 작성 기능 = 이미지 첨부하고 저장되는 것까지만 했다. >

1. 블로그컨트롤러 작성
@PostMapping("/addBlog.do")
  public String addBlog(HttpServletRequest request, RedirectAttributes redirectAttributes) {
    blogService.addBlog(request);
    return "";
  }
  
  
2. 블로그서비스 작성
public int addBlog(HttpServletRequest request);


3. 블로그서비스임플 작성
@Override
  public int addBlog(HttpServletRequest request) {
    
    String title = request.getParameter("title");
    String contents = request.getParameter("contents");
    int userNo = Integer.parseInt(request.getParameter("userNo"));
    
    return 0;
  }
  
  
4. BlogMapper.java 인터페이스로 만들기

5. BlogMapper.xml 만들기
<mapper namespace="com.gdu.myhome.dao.BlogMapper">

  <!-- 
    처리 순서
    1. BLOG_SEQ.NEXTVAL 값을 먼저(order="BEFORE") 파라미터로 전달된 BlogDto의 blogNo에 저장(keyProperty="blogNo")한다.
    2. 저장된 blogNo를 INSERT문에서 사용한다. 
   -->
  <insert id="insertBlog" parameterType="BlogDto">
    <selectKey order="BEFORE" keyProperty="blogNo" resultType="int">
      SELECT BLOG_SEQ.NEXTVAL
        FROM DUAL
    </selectKey>
    INSERT INTO BLOG_T(
        BLOG_NO
      , TITLE
      , CONTENTS
      , USER_NO
      , IP
      , CREATED_AT
      , MODIFIED_AT
    ) VALUES(
        #{blogNo}
      , #{title}
      , #{contents}
      , #{userNo}
      , #{ip}
      , TO_CHAR(SYSDATE, 'YYYY-MM-DD HH:MI:SS')
      , TO_CHAR(SYSDATE, 'YYYY-MM-DD HH:MI:SS')
    )
  </insert>
  
  </mapper>

6. BlogMapper.java 이어서 작성.
@Mapper
public interface BlogMapper {
  public int insertBlog(BlogDto blog);
}

8. BlogServiceImpl 작성
---------------------------------------------------------
상단에 작성
private final BlogMapper blogMapper;

하단에 작성
@Override
  public int addBlog(HttpServletRequest request) {
    
    String title = request.getParameter("title");
    String contents = request.getParameter("contents");
    int userNo = Integer.parseInt(request.getParameter("userNo"));
    String ip = request.getRemoteAddr();
    
    BlogDto blog = BlogDto.builder()
                    .title(title)
                    .contents(contents)
                    .userNo(userNo)
                    .ip(ip)
                    .build();
    
    int addResult = blogMapper.insertBlog(blog);
    
    return addResult;
  }
--------------------------------------------------------
  
  
 9.블로그컨트롤러 이어서 작성
 @PostMapping("/addBlog.do")
  public String addBlog(HttpServletRequest request, RedirectAttributes redirectAttributes) {
    int addResult = blogService.addBlog(request);
    redirectAttributes.addFlashAttribute("addResult", addResult);
    return "redirect:/blog/list.do";
  }
  
10. SQL디벨로퍼 BLOG_IMAGE_T 테이블 작성.

11. BlogImageDto 작성
@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class BlogImageDto {
  private int blogNo;
  private String imagePath;
  private String filesystemName;
}


12. mybatis-config.xml 에 BlogImageDto로 별명 만들기.
<typeAlias alias="BlogImageDto" type="com.gdu.myhome.dto.BlogImageDto"/>


13. pom.xml 에 메이븐 jsoup 추가 (나는 이미 등록함)
<!-- HTML 분석기 -->
<!-- https://mvnrepository.com/artifact/org.jsoup/jsoup -->
<dependency>
    <groupId>org.jsoup</groupId>
    <artifactId>jsoup</artifactId>
    <version>1.15.3</version>
</dependency>


14. BlogServiceImpl 작성 (자동완성 임폴트는 jsoup 패키지로 사용하기)
------------------------------------------------------------
@Override
  public int addBlog(HttpServletRequest request) {
    
    String title = request.getParameter("title");
    String contents = request.getParameter("contents");
    int userNo = Integer.parseInt(request.getParameter("userNo"));
    String ip = request.getRemoteAddr();
    
    // BlogDto 생성
    BlogDto blog = BlogDto.builder()
                    .title(title)
                    .contents(contents)
                    .userNo(userNo)
                    .ip(ip)
                    .build();
    
 // BLOG_T에 추가
    // BlogMapper의 insertBlog() 메소드를 실행하면
    // insertBlog() 메소드로 전달한 blog 객체에 blogNo값이 저장된다.
    int addResult = blogMapper.insertBlog(blog);
    
    // BLOG 작성시 사용한 이미지 목록 (Jsoup 라이브러리 사용)
    Document document = Jsoup.parse(contents);
    Elements elements =  document.getElementsByTag("img");
    
    if(elements != null) {
      for(Element element : elements) {
        String src = element.attr("src");
        String filesystemName = src.substring(src.lastIndexOf("/") + 1); 
        BlogImageDto blogImage = BlogImageDto.builder()
                                    .blogNo(blog.getBlogNo())
                                    .imagePath(myFileUtils.getBlogImagePath())
                                    .filesystemName(filesystemName)
                                    .build();
        blogMapper.insertBlogImage(blogImage);
      }
    }
    
    return addResult;
    
  }
------------------------------------------------------------

15. BlogMapper.xml 작성
<insert id="insertBlogImage" parameterType="BlogImageDto">
    INSERT INTO BLOG_IMAGE_T(
        BLOG_NO
      , IMAGE_PATH
      , FILESYSTEM_NAME
    ) VALUES(
        #{blogNo}
      , #{imagePath}
      , #{filesystemName}
    )
  </insert>
  
  
  
16. BlogMapper.java 작성
@Mapper
public interface BlogMapper {
  public int insertBlog(BlogDto blog);
  public int insertBlogImage(BlogImageDto blogImage);
}



17. MyFileUtils에 작성
// 블로그 이미지가 저장된 어제 경로를 반환
public String getBlogImagePathInYesterday() {
  LocalDate date = LocalDate.now();
  date = date.minusDays(1); // 1일 전
  return "/blog/" + DateTimeFormatter.ofPattern("yyyy/MM/dd").format(date);
}


18. BlogMapper.xml 작성
<select id="getBlogImageInYesterday" resultType="BlogImageDto">
   SELECT BLOG_NO, IMAGE_PATH, FILESYSTEM_NAME
     FROM BLOG_IMAGE_T
    WHERE IMAGE_PATH = '/blog/' || TO_CHAR(SYSDATE - 1, 'YYYY/MM/DD')
</select>


19. BlogMapper.java 작성
@Mapper
public interface BlogMapper {
  public int insertBlog(BlogDto blog);
  public int insertBlogImage(BlogImageDto blogImage);
  public List<BlogImageDto> getBlogImageInYesterday();	 <-- 이것 추가.
}


20. schedule 패키지에 BlogImageBatch 클래스 만들기
@RequiredArgsConstructor
@Component
public class BlogImageBatch {

  private final BlogService blogService;
  
  @Scheduled(cron="0 0 1 1/1 * ?")  // 매일 새벽 1시에 동작
  public void execute() {
    blogService.blogImageBatch();
  }
  
}



21. BlogService 작성
public interface BlogService {
  public Map<String, Object> imageUpload(MultipartHttpServletRequest multipartRequest);
  public int addBlog(HttpServletRequest request);
  public void blogImageBatch(); 	<- 이것 작성
}




22. BlogServiceImpl 작성
public void blogImageBatch() {
      
 // 1. 어제 작성된 블로그의 이미지 목록 (DB)
    List<BlogImageDto> blogImageList = blogMapper.getBlogImageInYesterday();
    
    // 2. List<BlogImageDto> -> List<Path> (Path는 경로+파일명으로 구성)                             * 패쓰형태 : /blog/2023/10/26
    List<Path> blogImagePathList = blogImageList.stream() // ↓ 해석 : blogImageDto를 경로하고 이름만 사용한 패쓰형태(경로형태)로 전부 다 바꿔서 리스트로 만들어달라.
                                                .map(blogImageDto -> new File(blogImageDto.getImagePath(), blogImageDto.getFilesystemName()).toPath())
                                                .collect(Collectors.toList());
    // 3. 어제 저장된 블로그 이미지 목록 (디렉토리)
    File dir = new File(myFileUtils.getBlogImagePathInYesterday());
    
    // 4. 삭제할 File 객체들   // ↓ 해석 : 디렉토리에 저장된 모든 애들을 파일이라고 하고 하나씩 불러서 경로에 포함되어있는지 확인하고 true인 대상들만 넘겨줄 것이다.
    File[] targets = dir.listFiles(file -> !blogImagePathList.contains(file.toPath()));
                                  //   ↑ 람다식으로 함 (for문으로 하면 구문이 길어지고 이상해짐)
    // 5. 삭제
    if(targets != null && targets.length !=0) {
      for(File target : targets) {
        target.delete();
      }
    }
  }
===========블로그 이미지 첨부하고 폴더 저장되는 기능까지 했다.==============