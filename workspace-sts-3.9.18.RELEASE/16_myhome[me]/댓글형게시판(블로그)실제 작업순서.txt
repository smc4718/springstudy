< 댓글형 게시판 작업 >

[ 블로그 작업 ]

1. UserDto 와 InactiveUserDto 작성
private int state; 추가


2. BlogDto 만들어서 작성.
@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder		// 쉬운 생성을 도와주는 빌더패턴
public class BlogDto {
  private int blogNo;
  private String title;
  private String contents;
  private int userNo;
  private int hit;
  private String ip;
  private String createdAt;
  private String modifiedAt;
}


3. CommentDto 만들어서 작성.
@NoArgsConstructorㅒ
@AllArgsConstructor
@Data
@Builder		// 쉬운 생성을 도와주는 빌더패턴
public class CommentDto {
  private int commentNo;
  private String contents;
  private int userNo;
  private int blogNo;
  private String createdAt;
  private int status;
  private int depth;
  private int groupNo;
}


4.  Dto의 원래 타입이름이 길기 때문에(패키지 이름으로 나옴) mybatis-config.xml 에 가서 별명 만들기.
<typeAlias alias="BlogDto" type="com.gdu.myhome.dto.BlogDto"/>
<typeAlias alias="CommentDto" type="com.gdu.myhome.dto.CommentDto"/>


--------------------------------------------------
[ 파일 첨부 기능 ]

< ===================파일 첨부를 위한 사전작업과============================
=====================새 글 작성시 이미지 첨부하는 기능 =================>

< 블로그 작성시 첨부한 이미지가 작성 후에도 저장되게 하기 >

1. pom.xml에 파일첨부 넣기 (나는 이미 pom에 들어가있음, 추가 X)
 <!-- 파일 첨부(commons-io + commons-fileupload) -->
    <!-- https://mvnrepository.com/artifact/commons-io/commons-io -->
    <dependency>
      <groupId>commons-io</groupId>
      <artifactId>commons-io</artifactId>
      <version>2.8.0</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload -->
    <dependency>
      <groupId>commons-fileupload</groupId>
      <artifactId>commons-fileupload</artifactId>
      <version>1.5</version>
    </dependency>


2. FileConfig.java 작성
@Configuration
public class FileConfig {

  // MultipartResolver 라는 빈이 없으면 파일첨부가 불가능하다.
  @Bean
  public MultipartResolver multipartResolver() {  // 항상 인터페이스가 있으면 인터페이스 타입으로 잡기.
    CommonsMultipartResolver commonsMultipartResolver = new CommonsMultipartResolver();
    commonsMultipartResolver.setDefaultEncoding("UTF-8");
    commonsMultipartResolver.setMaxUploadSize(1024 * 1024 * 100); // 전체 첨부 파일의 크기 100메가 = 1mg x 1mg x 100 : 100메가.
    commonsMultipartResolver.setMaxUploadSizePerFile(1024 * 1024 * 10); // 개별 첨부 파일의 최대 크기 10메가 = 1mg x 1mg x 10 :  10메가.
    return commonsMultipartResolver;
  }
  
}


3. MyFileUtils.java 작성
@Component
public class MyFileUtils {   // @Component 해놓고 불러다가 @Autowired 로 쓸 것.

  // 블로그 작성시 사용된 이미지가 저장될 경로 반환하기
  public String getBlogImagePath() {
    /*  /storage/yyyy/MM/dd */
    LocalDate today = LocalDate.now();  // 오늘을 구하는 방법
   return "/blog/" + DateTimeFormatter.ofPattern("yyyy/MM/DD").format(today);
  }
  
  // 파일이 저장될 이름 반환하기 (파일을 올릴 때 이름과, 실제 저장될 때 이름은 다르다)
  public String getFilesystemName(String originalFileName) { // Filesystem 은 한 단어임.
    
    /*  UUID.확장자  */
    
    String extName = null;
    if(originalFileName.endsWith("tar.gz")) { // 확장자에 마침표가 포함되는 예외 경우를 처리한다.
      extName = "tar.gz";
    } else {                                    // 자동완성시 regex 있으면 정규식 입력하라는 의미. 정규식에서 '.' 는 모든 문자라는 성격을 가지고 있음.
      String[] arr = originalFileName.split("\\.");  // 마침표를 문자로 만들어주려면, [.] 또는 \\. 으로 입력.
      extName = arr[arr.length-1];
    }   
    //   ↑↑↑ 확장자 만드는 식
    
    return UUID.randomUUID().toString().toString().replace("-", "") + "." + extName; // ← 원래 이름과 저장된 이름 구성하기.
  }

--------------------------------------------------
  
< 블로그 작업 이어서 >
  
5. header.jsp 작성
<li><a href="${contextPath}/blog/list.do">댓글형게시판</a></li>



6. BlogController 만들기
@RequestMapping("/blog")
@Controller
public class BlogController {

  @GetMapping("/list.do")
  public String list(HttpServletRequest request, Model model) {
    return "blog/list";
  }
  
}



7. view에 blog폴더 만들고 list.jsp 작성
<div>
  <a href="${contextPath}/blog/write.form">
    <button type="button" class="btn btn-primary">새글작성</button>
  </a>
</div>



8. blogController 이어서 작성
@GetMapping("/list.do")
  public String list(HttpServletRequest request, Model model) {
    return "blog/list";
  }
  
  @GetMapping("/write.form")
  public String write() {
    return "blog/write";
  }



9. write.jsp 작성
------------------------------------------------------
<jsp:include page="../layout/header.jsp">
  <jsp:param value="블로그작성" name="title"/>
</jsp:include>

<style>
  .ck.ck-editor {
    max-width: 800px;
  }
  .ck-editor__editable {
    min-height: 400px;
  }
  .ck-content {
    color: gray;
  }
</style>

<div>
    <!-- form id="frm_blog_add"는 title의 공백을 검사할 때 사용한다.(지금은 사용 안한 버젼 -->
  <form id="frm_blog_add" method="post" action="${contextPath}/blog/addBlog.do">
    
    <h1>블로그를 작성하세요</h1>
    
    <div>
      <label for="title">제목</label>
      <input type="text" name="title" id="title">
    </div>
    
    <div>
      <label for="contents">내용</label>
      <textarea name="contents" id="contents"></textarea>
    </div>
    
    <div>
      <input type="hidden" name="userNo" value="${sessionScope.user.userNo}"> <!-- 세션에 있는 유저에 있는 유저넘버 -->
      <button type="submit">작성완료</button>
    </div>
    
  </form>

  <script>
    const fnCkeditor = () => {		// 화살표 함수로 변수로 전달하는 방식
  		 
  	  ClassicEditor
  	    .create(document.getElementById('contents'), {	//	getElementById('?')  <- 물음표 자리는 상황에 따라 이름을 바꿔서 써야 한다. 
  		    toolbar: {
  			    items: [
  		        'undo', 'redo',
  		        '|', 'heading',
  		        '|', 'fontfamily', 'fontsize', 'fontColor', 'fontBackgroundColor',
  		        '|', 'bold', 'italic', 'strikethrough', 'subscript', 'superscript', 'code',
  		        '|', 'link', 'uploadImage', 'blockQuote', 'codeBlock',
  		        '|', 'bulletedList', 'numberedList', 'todoList', 'outdent', 'indent'
    		    ],
    		    shouldNotGroupWhenFull: false
    	   },
         heading: {
           options: [
             { model: 'paragraph', title: 'Paragraph', class: 'ck-heading_paragraph' },
             { model: 'heading1', view: 'h1', title: 'Heading 1', class: 'ck-heading_heading1' },
             { model: 'heading2', view: 'h2', title: 'Heading 2', class: 'ck-heading_heading2' },
             { model: 'heading3', view: 'h3', title: 'Heading 3', class: 'ck-heading_heading3' },
             { model: 'heading4', view: 'h4', title: 'Heading 4', class: 'ck-heading_heading4' },
             { model: 'heading5', view: 'h5', title: 'Heading 5', class: 'ck-heading_heading5' },
             { model: 'heading6', view: 'h6', title: 'Heading 6', class: 'ck-heading_heading6' }
           ]
         },
         ckfinder: {
      	   // 업로드 경로 (블로그 경로로 이미지 업로드를 하겠다.)
      	   uploadUrl: '${contextPath}/blog/imageUpload.do'
         }
  	   })
  	   .catch(err => {
  		   console.log(err)
  	   });
  	  
    }
    
    // 함수 호출
    fnCkeditor();
    
  </script>

</div>

<%@ include file="../layout/footer.jsp" %>
----------------------------------------------


10. servlet-context.xml 작성
<interceptor>
  <mapping path="/user/mypage.form"/>
  <mapping path="/user/modifyPw.form"/>
  <mapping path="/free/write.form"/>
  <mapping path="/blog/write.form"/>	<-- 이걸 추가 (로그인 되어있는지 검사)
  <beans:bean class="com.gdu.myhome.intercept.RequiredLoginInterceptor" />  <!-- 필수 로그인 인터셉터 : RequiredLoginInterceptor -->
</interceptor>


11. BlogService 인터페이스와 BlogServiceImpl.java(BlogService 인터페이스 추가) 만들기.

12. BlogController에 작성
private final BlogService blogService;

그리고 클래스 상단에 @RequiredArgsConstructor 붙이기.

추가 작성 :
// produces 가 있으면, 무조건 @ResponseBody 가 붙는다 (ajax처럼 동작하기 때문) 
  // 첨부 파일 관련된 것은 전부 다 POST 다. (주소창에 파일 못 붙임)
  // json을 반환할 때 최적화된 것 : Map
  @ResponseBody
  @PostMapping(value="/imageUpload.do", produces="application/json") // value만 작성할 때는 value를 생략할 수 있지만, 또 적을 게 있다면 value를 꼭 적어주어야 함.
  public Map<String, Object> imageUpload(MultipartHttpServletRequest multipartRequest) {   // MultipartHttpServletRequest : 파일을 받을 수 있는 MultipartHttpServletRequest 
    return blogService.imageUpload(multipartRequest);
  }
  
  
13. BlogService 작성
public interface BlogService {
  public Map<String, Object> imageUpload(MultipartHttpServletRequest multipartRequest);
}


14.BlogServiceImpl 작성
--------------------------------------------------------------- 
@RequiredArgsConstructor
@Service
public class BlogServiceImpl implements BlogService {
  
  private final MyFileUtils myFileUtils;
  
  @Override
  public Map<String, Object> imageUpload(MultipartHttpServletRequest multipartRequest) {
   
    // 이미지가 저장될 경로
    String imagePath = myFileUtils.getBlogImagePath();
    File dir = new File(imagePath);
    if(!dir.exists()) {
      dir.mkdirs();
    }
    
    // 이미지 파일 (CKEditor는 이미지를 upload 라는 이름으로 보냄)
    MultipartFile upload = multipartRequest.getFile("upload");
    
    // 이미지가 저장될 이름
    String originalFilename = upload.getOriginalFilename();
    String filesystemName = myFileUtils.getFilesystemName(originalFilename);  // 저장될 이름을 제공한다.
    
    // 이미지 File 객체
    File file = new File(dir, filesystemName);   // 경로는 dir , 저장된 이름은 filesystemName
    
    // 저장
    try {
      upload.transferTo(file);  // file을 보내라.
    } catch (Exception e) {
      e.printStackTrace();
    }
    
    // CKEditor로 저장된 이미지의 경로를 JSON 형식으로 반환해야 함
    return Map.of("uploaded", true  // 업로드 되었다, 그렇다.
                , "url", multipartRequest.getContextPath() + imagePath + "/" + filesystemName);  // 이미지가 저장될 경로. 
  
    // url: "http://localhost:8080/myhome/blog/2023/10/27/파일명"  <- CKEditor로 이 주소를 보냈다.
    // servlet-context.xml에
    // /blog/** 주소 요청을 실제 저장될 디렉토리인  /blog 디렉터리로 연결하는 <resources> 태그를 추가해야 함.
  
  }
--------------------------------------------------------------- 


15. servlet-context.xml에 작성
<!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory -->
 <resources mapping="/resources/**" location="/resources/" />
 <resources mapping="/blog/**" location="file:///blog/" />   <!-- file:// 를 붙이면 프로젝트 내부 폴더가 아닌, 외부 폴더 경로로 인식한다. --> 

===================여기까지 새 글 작성시 이미지 첨부하는 기능============================
 
< 블로그 작성 기능 = 이미지 첨부하고 저장되는 것까지만 했다. >

1. 블로그컨트롤러 작성
@PostMapping("/addBlog.do")
  public String addBlog(HttpServletRequest request, RedirectAttributes redirectAttributes) {
    blogService.addBlog(request);
    return "";
  }
  
  
2. 블로그서비스 작성
public int addBlog(HttpServletRequest request);


3. 블로그서비스임플 작성
@Override
  public int addBlog(HttpServletRequest request) {
    
    String title = request.getParameter("title");
    String contents = request.getParameter("contents");
    int userNo = Integer.parseInt(request.getParameter("userNo"));
    
    return 0;
  }
  
  
4. BlogMapper.java 인터페이스로 만들기

5. BlogMapper.xml 만들기
<mapper namespace="com.gdu.myhome.dao.BlogMapper">

  <!-- 
    처리 순서
    1. BLOG_SEQ.NEXTVAL 값을 먼저(order="BEFORE") 파라미터로 전달된 BlogDto의 blogNo에 저장(keyProperty="blogNo")한다.
    2. 저장된 blogNo를 INSERT문에서 사용한다. 
   -->
  <insert id="insertBlog" parameterType="BlogDto">
    <selectKey order="BEFORE" keyProperty="blogNo" resultType="int">
      SELECT BLOG_SEQ.NEXTVAL
        FROM DUAL
    </selectKey>
    INSERT INTO BLOG_T(
        BLOG_NO
      , TITLE
      , CONTENTS
      , USER_NO
      , IP
      , CREATED_AT
      , MODIFIED_AT
    ) VALUES(
        #{blogNo}
      , #{title}
      , #{contents}
      , #{userNo}
      , #{ip}
      , TO_CHAR(SYSDATE, 'YYYY-MM-DD HH:MI:SS')
      , TO_CHAR(SYSDATE, 'YYYY-MM-DD HH:MI:SS')
    )
  </insert>
  
  </mapper>

6. BlogMapper.java 이어서 작성.
@Mapper
public interface BlogMapper {
  public int insertBlog(BlogDto blog);
}

8. BlogServiceImpl 작성
---------------------------------------------------------
상단에 작성
private final BlogMapper blogMapper;

하단에 작성
@Override
  public int addBlog(HttpServletRequest request) {
    
    String title = request.getParameter("title");
    String contents = request.getParameter("contents");
    int userNo = Integer.parseInt(request.getParameter("userNo"));
    String ip = request.getRemoteAddr();
    
    BlogDto blog = BlogDto.builder()
                    .title(title)
                    .contents(contents)
                    .userNo(userNo)
                    .ip(ip)
                    .build();
    
    int addResult = blogMapper.insertBlog(blog);
    
    return addResult;
  }
--------------------------------------------------------
  
  
 9.블로그컨트롤러 이어서 작성
 @PostMapping("/addBlog.do")
  public String addBlog(HttpServletRequest request, RedirectAttributes redirectAttributes) {
    int addResult = blogService.addBlog(request);
    redirectAttributes.addFlashAttribute("addResult", addResult);
    return "redirect:/blog/list.do";
  }
  
10. SQL디벨로퍼 BLOG_IMAGE_T 테이블 작성.

11. BlogImageDto 작성
@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class BlogImageDto {
  private int blogNo;
  private String imagePath;
  private String filesystemName;
}


12. mybatis-config.xml 에 BlogImageDto로 별명 만들기.
<typeAlias alias="BlogImageDto" type="com.gdu.myhome.dto.BlogImageDto"/>


13. pom.xml 에 메이븐 jsoup 추가 (나는 이미 등록함)
<!-- HTML 분석기 -->
<!-- https://mvnrepository.com/artifact/org.jsoup/jsoup -->
<dependency>
    <groupId>org.jsoup</groupId>
    <artifactId>jsoup</artifactId>
    <version>1.15.3</version>
</dependency>


14. BlogServiceImpl 작성 (자동완성 임폴트는 jsoup 패키지로 사용하기)
------------------------------------------------------------
@Override
  public int addBlog(HttpServletRequest request) {
    
    String title = request.getParameter("title");
    String contents = request.getParameter("contents");
    int userNo = Integer.parseInt(request.getParameter("userNo"));
    String ip = request.getRemoteAddr();
    
    // BlogDto 생성
    BlogDto blog = BlogDto.builder()
                    .title(title)
                    .contents(contents)
                    .userNo(userNo)
                    .ip(ip)
                    .build();
    
 // BLOG_T에 추가
    // BlogMapper의 insertBlog() 메소드를 실행하면
    // insertBlog() 메소드로 전달한 blog 객체에 blogNo값이 저장된다.
    int addResult = blogMapper.insertBlog(blog);
    
    // BLOG 작성시 사용한 이미지 목록 (Jsoup 라이브러리 사용)
    Document document = Jsoup.parse(contents);
    Elements elements =  document.getElementsByTag("img");
    
    if(elements != null) {
      for(Element element : elements) {
        String src = element.attr("src");
        String filesystemName = src.substring(src.lastIndexOf("/") + 1); 
        BlogImageDto blogImage = BlogImageDto.builder()
                                    .blogNo(blog.getBlogNo())
                                    .imagePath(myFileUtils.getBlogImagePath())
                                    .filesystemName(filesystemName)
                                    .build();
        blogMapper.insertBlogImage(blogImage);
      }
    }
    
    return addResult;
    
  }
------------------------------------------------------------

15. BlogMapper.xml 작성
<insert id="insertBlogImage" parameterType="BlogImageDto">
    INSERT INTO BLOG_IMAGE_T(
        BLOG_NO
      , IMAGE_PATH
      , FILESYSTEM_NAME
    ) VALUES(
        #{blogNo}
      , #{imagePath}
      , #{filesystemName}
    )
  </insert>
  
  
  
16. BlogMapper.java 작성
@Mapper
public interface BlogMapper {
  public int insertBlog(BlogDto blog);
  public int insertBlogImage(BlogImageDto blogImage);
}



17. MyFileUtils에 작성
// 블로그 이미지가 저장된 어제 경로를 반환
public String getBlogImagePathInYesterday() {
  LocalDate date = LocalDate.now();
  date = date.minusDays(1); // 1일 전
  return "/blog/" + DateTimeFormatter.ofPattern("yyyy/MM/dd").format(date);
}


18. BlogMapper.xml 작성
<select id="getBlogImageInYesterday" resultType="BlogImageDto">
   SELECT BLOG_NO, IMAGE_PATH, FILESYSTEM_NAME
     FROM BLOG_IMAGE_T
    WHERE IMAGE_PATH = '/blog/' || TO_CHAR(SYSDATE - 1, 'YYYY/MM/DD')
</select>


19. BlogMapper.java 작성
@Mapper
public interface BlogMapper {
  public int insertBlog(BlogDto blog);
  public int insertBlogImage(BlogImageDto blogImage);
  public List<BlogImageDto> getBlogImageInYesterday();	 <-- 이것 추가.
}


20. schedule 패키지에 BlogImageBatch 클래스 만들기
@RequiredArgsConstructor
@Component
public class BlogImageBatch {

  private final BlogService blogService;
  
  @Scheduled(cron="0 0 1 1/1 * ?")  // 매일 새벽 1시에 동작
  public void execute() {
    blogService.blogImageBatch();
  }
  
}



21. BlogService 작성
public interface BlogService {
  public Map<String, Object> imageUpload(MultipartHttpServletRequest multipartRequest);
  public int addBlog(HttpServletRequest request);
  public void blogImageBatch(); 	<- 이것 작성
}




22. BlogServiceImpl 작성
public void blogImageBatch() {
      
 // 1. 어제 작성된 블로그의 이미지 목록 (DB)
    List<BlogImageDto> blogImageList = blogMapper.getBlogImageInYesterday();
    
    // 2. List<BlogImageDto> -> List<Path> (Path는 경로+파일명으로 구성)                             * 패쓰형태 : /blog/2023/10/26
    List<Path> blogImagePathList = blogImageList.stream() // ↓ 해석 : blogImageDto를 경로하고 이름만 사용한 패쓰형태(경로형태)로 전부 다 바꿔서 리스트로 만들어달라.
                                                .map(blogImageDto -> new File(blogImageDto.getImagePath(), blogImageDto.getFilesystemName()).toPath())
                                                .collect(Collectors.toList());
    // 3. 어제 저장된 블로그 이미지 목록 (디렉토리)
    File dir = new File(myFileUtils.getBlogImagePathInYesterday());
    
    // 4. 삭제할 File 객체들   // ↓ 해석 : 디렉토리에 저장된 모든 애들을 파일이라고 하고 하나씩 불러서 경로에 포함되어있는지 확인하고 true인 대상들만 넘겨줄 것이다.
    File[] targets = dir.listFiles(file -> !blogImagePathList.contains(file.toPath()));
                                  //   ↑ 람다식으로 함 (for문으로 하면 구문이 길어지고 이상해짐)
    // 5. 삭제
    if(targets != null && targets.length !=0) {
      for(File target : targets) {
        target.delete();
      }
    }
  }
===========블로그 이미지 첨부하고 폴더 저장되는 기능까지 했다.==============

< 이어서 >

23(2). SQL 추가 작성


24. list.jsp 작성(틀만 잡기)
<div>
    순번  제목  조회수  작성자(이메일) 작성일
</div>



25. blogDto 작성
private UserDto userDto;  // = private int userNo;  -  매퍼.xml에서 association 태그를 쓴 것은 맨 아래에 놓기.



26. blogMapper.xml 수정 및 작성
----------------------------------------------
수정할 것(resultType) : <select id="getBlogList" parameterType="Map" resultMap="BlogMap">

작성할 것 :
<resultMap type="BlogDto"      id="BlogMap">
    <id     column="BLOG_NO"     property="blogNo" />
    <result column="TITLE"       property="title" />
    <result column="CONTENTS"    property="contents" />
    <result column="HIT"         property="hit" />
    <result column="IP"          property="ip" />
    <result column="CREATED_AT"  property="createdAt" />
    <result column="MODIFIED_AT" property="modifiedAt" />
    <association javaType="UserDto"      property="userDto">
      <id        column="USER_NO"        property="userNo"/>
      <result    column="EMAIL"          property="email" />
      <result    column="PW"             property="pw" />
      <result    column="NAME"           property="name" />
      <result    column="GENDER"         property="gender" />
      <result    column="MOBILE"         property="mobile" />
      <result    column="POSTCODE"       property="postcode" />
      <result    column="ROAD_ADDRESS"   property="roadAddress" />
      <result    column="JIBUN_ADDRESS"  property="jibunAddress" />
      <result    column="DETAIL_ADDRESS" property="detailAddress" />
      <result    column="AGREE"          property="agree" />
      <result    column="STATE"          property="state" />
      <result    column="PW_MODIFIED_AT" property="pwModifiedAt" />
      <result    column="JOINED_AT"      property="joinedAt" />
    </association>
  </resultMap>
  
  <select id="getBlogCount" resultType="int">
    SELECT COUNT(*)
      FROM BLOG_T
  </select>
  
  <select id="getBlogList" parameterType="Map" resultType="BlogMap">
    SELECT A.BLOG_NO, A.TITLE, A.CONTENTS, A.USER_NO, A.HIT, A.IP, A.CREATED_AT, A.MODIFIED_AT, A.EMAIL
      FROM (SELECT ROW_NUMBER() OVER(ORDER BY B.BLOG_NO DESC) AS RN, B.BLOG_NO, B.TITLE, B.CONTENTS, B.USER_NO, B.HIT, B.IP, B.CREATED_AT, B.MODIFIED_AT, U.EMAIL
              FROM USER_T U INNER JOIN BLOG_T B
                ON B.USER_NO = U.USER_NO) A
     WHERE A.RN BETWEEN #{begin} AND #{end}
  </select>
  ----------------------------------------------



27. 서비스임플 작성 (기존 작성에서 수정)
 // BlogDto 생성
    BlogDto blog = BlogDto.builder()
                    .title(title)
                    .contents(contents)
                    .userDto(UserDto.builder()
                              .userNo(userNo)
                              .build())
                    .ip(ip)
                    .build();
                    
     


28.매퍼.xml 수정
insertBlog 부분 insert 태그 내용에
#{userNo} 를 #{userDto.userNo} 로 수정.


29.매퍼.java 작성
public int getBlogCount();
public List<BlogDto> getBlogList(Map<String, Object> map);


30.서비스 작성
public void loadBlogList(HttpServletRequest request, Model model);


31.서비스임플 작성
클래스 상단에 추가 : 
@Transactional
@RequiredArgsConstructor
@Service
public class BlogServiceImpl implements BlogService {

하단에 추가 :
@Transactional(readOnly=true)
  @Override
  public void loadBlogList(HttpServletRequest request, Model model) {
    
    Optional<String> opt = Optional.ofNullable(request.getParameter("page")); // page 파라미터를 Optional로 감싸기.
    int page = Integer.parseInt(opt.orElse("1")); // 페이지 파라미터가 없으면 1을 대신 꺼내 쓰세요.
    int total = blogMapper.getBlogCount();
    int display = 10;
    
    myPageUtils.setPaging(page, total, display);
    
    Map<String, Object> map = Map.of("begin", myPageUtils.getBegin()
                                   , "end", myPageUtils.getEnd());
    
    List<BlogDto> blogList = blogMapper.getBlogList(map);
    
    model.addAttribute("blogList", blogList);
    model.addAttribute("paging", myPageUtils.getMvcPaging(request.getContextPath() + "/blog/list.do"));
    model.addAttribute("beginNo", total - (page - 1) * display); // 페이지당 첫 순서의 시작번호 계산.
    
  }

  
32.컨트롤러 작성
@GetMapping("/list.do")
  public String list(HttpServletRequest request, Model model) {
    blogService.loadBlogList(request, model);
    return "blog/list";
  }


33. list.jsp 작성
-----------------------------------------
<div>
    <table border="1">
      <thead>
        <tr>
          <td>순번</td>
          <td>제목</td>
          <td>조회수</td>
          <td>작성자(이메일)</td>
          <td>작성일자</td>
        </tr>
      </thead>
      <tbody>
        <c:forEach items="${blogList}" var="b" varStatus="vs">
          <tr>
            <td>${beginNo - vs.index}</td>
            <td>${b.title}</td>
            <td>${b.hit}</td>
            <td>${b.userDto.email}</td> <!-- userDto 에서 email을 꺼내야 한다. -->
            <td>${b.createdAt}</td>
          </tr>
        </c:forEach>
      </tbody>
      <tfoot>
        <tr>
          <td colspan="5">${paging}</td>
        </tr>
      </tfoot>
    </table>
  </div>
--------------------------------------------

34. write.jsp 수정
<div>
   <input type="hidden" name="userNo" value="${sessionScope.user.userNo}">   <- 이것 수정
   <button type="submit" class="btn btn-success">작성완료</button>
</div>



-------------------------------------------

[ 블로그 상세보기 작업 순서]
1. SQL 작성
-- 2. 상세

-- 1) 조회수 증가
UPDATE BLOG_T
   SET HIT = HIT + 1
 WHERE BLOG_NO = 1;

-- 2) 블로그 상세 정보 조회
SELECT B.BLOG_NO, B.TITLE, B.CONTENTS, B.HIT, B.IP, B.CREATED_AT, B.MODIFIED_AT, U.USER_NO, U.EMAIL, U.NAME
  FROM USER_T U, BLOG_T B
 WHERE U.USER_NO = B.USER_NO
   AND B.BLOG_NO = 1;
   
   
   
   
2. 매퍼.xml 작성
<update id="updateHit" parameterType="int">
  UPDATE BLOG_T
     SET HIT = HIT + 1
   WHERE BLOG_NO = #{blogNo}
</update>

<select id="getBlog" parameterType="int" resultMap="BlogMap">
 <!-- 오라클 문법 (위,아래 둘 중 하나만 써) -->
  SELECT B.BLOG_NO, B.TITLE, B.CONTENTS, B.HIT, B.IP, B.CREATED_AT, B.MODIFIED_AT, U.USER_NO, U.EMAIL, U.NAME
    FROM USER_T U, BLOG_T B
   WHERE U.USER_NO = B.USER_NO
     AND B.BLOG_NO = #{blogNo}
</select>




2. 매퍼.java 작성
public int updateHit(int blogNo);
public BlogDto getBlog(int blogNo);



3. 서비스 작성
public int increaseHit(int blogNo);
public BlogDto getBlog(int blogNo);



4. 서비스 임플 작성
  @Override
  public int increaseHit(int blogNo) {
    return blogMapper.updateHit(blogNo);
  }
  
  @Override
  public BlogDto getBlog(int blogNo) {
    return blogMapper.getBlog(blogNo);
  }
  
 
  
5. 컨트롤러 작성
-----------------------------------------
@GetMapping("/increaseHit.do")
  public String increaseHit(@RequestParam(value="blogNo", required=false, defaultValue="0") int blogNo) {
  int increaseResult = blogService.increaseHit(blogNo);
  if(increaseResult == 1) {
    return "redirect:/blog/detail.do?blogNo=" + blogNo; // 위에서 조회수 증가가 나오고, 여기서 상세보기가 나온다.
  } else {
    return "redirect:/blog/list.do";
  }
  }
  
  @GetMapping("/detail.do")
  public String detail(@RequestParam(value="blogNo", required=false, defaultValue="0") int blogNo
                     , Model model) {
    BlogDto blog = blogService.getBlog(blogNo);
    model.addAttribute("blog", blog);
    return "blog/detail";  // 내가 작성한 블로그는 조회수가 늘지 않도록 detail로 보내기.  // 내가 작성하지 않은 블로그는 조회수가 늘도록 increaseHit 로 보내기.
  }
---------------------------------------------



6. list.jsp 에 추가작성
--------------------------------------
<tr>
  <td>${beginNo - vs.index}</td>
  <td>
<!-- 내가 작성한 블로그의 조회수는 증가하지 않는다. -->
   <c:if test="${sessionScope.user.userNo == b.userDto.userNo}">
     <a href="${contextPath}/blog/detail.do?blogNo=${b.blogNo}">${b.title}</a>
   </c:if>
<!-- 내가 작성하지 않았다면 조회수를 증가시킨 뒤 상세보기 요청을 한다. -->
   <c:if test="${sessionScope.user.userNo !== b.userDto.userNo}">
     <a href="${contextPath}/blog/increaseHit.do?blogNo=${b.blogNo}">${b.title}</a>
   </c:if>
  </td>
  <td>${b.title}</td>
  <td>${b.hit}</td>
  <td>${b.userDto.email}</td> <!-- userDto 에서 email을 꺼내야 한다. -->
  <td>${b.createdAt}</td>
</tr>
----------------------------------------



7. detail.jsp 만들기
--------------------------------------------------
<div>

  <!-- 블로그 상세보기 -->
  <div>
    <h1>${blog.title}</h1>
    <div>작성자 : ${blog.userDto.name}</div>
    <div>조회수 : ${blog.hit}</div>
    <div>작성IP : ${blog.ip}</div>
    <div>작성일 : ${blog.createdAt}</div>
    <div>수정일 : ${blog.modifiedAt}</div>
    <div>
      버튼구역
    </div>
    <div>${blog.contents}</div>
  </div>
  
  <hr>
  
  <!-- 댓글 작성 화면 -->
  <div>
    <form id="frm_comment_add">
      <textarea rows="3" cols="50" name="contents" placeholder="댓글을 작성해 주세요"></textarea>
      <input type="hidden" name="userNo" value="${sessionScope.user.userNo}">   <!-- 세션에 있는 유저에 유저넘버 -->
      <input type="hidden" name="blogNo" value="${blog.blogNo}">
      <button type="button" id="btn_comment_add">작성완료</button>
    </form>
    <script>
    
      const fnRequiredLogin = () => {    	  
        // 로그인을 안하고 작성을 시도하면 로그인 페이지로 보내기
        $('#contents, #btn_comment_add').click(() => {
      	  if('${sessionScope.user}' === ''){
      		  if(confirm('로그인이 필요한 기능입니다. 로그인할까요?')){
      			  location.href = '${contextPath}/user/login.form';
      		  } else {
      			  return;
      		  }
      	  }
        })
      }
      
      const fnCommentAdd = () => {
    	  $('#btn_comment_add').click(() => {
    		  $.ajax({
    			  // 요청
    			  type: 'post',
    			  url: '${contextPath}/blog/addComment.do',
    			  data: $('#frm_comment_add').serialize(),
    			  // 응답
    			  dataType: 'json',
    			  success: (resData) => {
    				  console.log(resData);
    			  }
    		  })
    	  })
      }
      
      fnRequiredLogin();
      fnCommentAdd();
      
      
    </script>
  </div>
  
  <!-- 블로그 댓글 목록 -->
  <div id="comment_list"></div>
  <script>
  	
  </script>

</div>
------------------------------------------------------


8.매퍼.xml 작성
<insert id="insertComment" parameterType="CommentDto">
    INSERT INTO COMMENT_T(
        COMMENT_NO
      , CONTENTS
      , USER_NO
      , BLOG_NO
      , CREATED_AT
      , STATUS
      , DEPTH
      , GROUP_NO
    ) VALUES(
        COMMENT_SEQ.NEXTVAL
      , #{contents}
      , #{userNo}
      , #{blogNo}
      , TO_CHAR(SYSDATE, 'YYYY-MM-DD HH:MI:SS')  <!-- CREATED_AT -->
      , 1   <!-- DEPTH -->
      , 0   <!-- GROUP_NO -->
      , COMMENT_SEQ.CURRVAL
    )
</insert>



9. 매퍼.java 작성
public int insertComment(CommentDto comment);


10. 서비스작성
public Map<String, Object> addComment(HttpServletRequest request); 

11. 서비스임플 작성
  @Override
  public Map<String, Object> addComment(HttpServletRequest request) {
    
    String contents = request.getParameter("contents");
    int userNo = Integer.parseInt(request.getParameter("userNo"));
    int blogNo = Integer.parseInt(request.getParameter("blogNo"));
    
    CommentDto comment = CommentDto.builder()
                           .contents(contents)
                           .userNo(userNo)
                           .blogNo(blogNo)
                           .build();
    
    int addCommentResult = blogMapper.insertComment(comment);
    
    return Map.of("addCommentResult",addCommentResult);
  }
  

12. 컨트롤러 작성
@ResponseBody
  @PostMapping(value="/addComment.do", produces="application/json")
  public Map<String, Object> addComment(HttpServletRequest request) {
    return blogService.addComment(request);
  }
  


13. 매퍼.xml 작성
<select id="getCommentCount" parameterType="int" resultType="int">    <!-- 항상 목록을 구할 때는 갯수(Count)가 필요했다. -->
    SELECT COUNT(*)
      FROM COMMENT_T
     WHERE BLOG_NO = #{blogNo}
</select>
  
<select id="getCommentList" parameterType="Map">
  SELECT A.COMMENT_NO, A.CONTENTS, A.USER_NO, A.BLOG_NO, A.CREATED_AT, A.STATUS, A.DEPTH, A.GROUP_NO, A.USER_NO, A.NAME
    FROM (SELECT ROW_NUMBER() OVER(ORDER BY GROUP_NO DESC, DEPTH ASC, COMMENT_NO DESC) AS RN, C.COMMENT_NO, C.CONTENTS, C.USER_NO, C.BLOG_NO, C.CREATED_AT, C.STATUS, C.DEPTH, C.GROUP_NO, U.USER_NO, U.NAME
            FROM USER_T U INNER JOIN COMMENT_T C
              ON U.USER_NO = C.USER_NO
           WHERE C.BLOG_NO = #{blogNo) A
   WHERE A.RN BETWEEN #{begin} AND #{end};  <!-- Map에 들어있는 게 blog_no , begin, end. 이렇게 3개다. -->  
</select>


14. 매퍼.java 작성
public int getCommentCount(int blogNo);
public List<CommentDto> getCommentList(Map<String, Object> map);


15. CommentDto 작성 (맨 하단에 적기)
private UserDto userDto;  	// private int userNo;


16. 매퍼.xml작성
<resultMap type="CommentDto"    id="CommentMap">     <!-- 사용자에 관한 모든 정보를 댓글과 함께 나타낼 수 있습니다. -->  
    <id      column="COMMENT_NO"  property="commentNo" />
    <result  column="CONTENTS"    property="contents" />
    <result  column="BLOG_NO"    property="blogNo" />
    <result  column="CREATED_AT"    property="createdAt" />
    <result  column="STATUS"    property="status" />
    <result  column="DEPTH"    property="depth" />
    <result  column="GROUP_NO"    property="groupNo" />
    <association javaType="UserDto"      property="userDto">
      <id        column="USER_NO"        property="userNo"/>
      <result    column="EMAIL"          property="email" />
      <result    column="PW"             property="pw" />
      <result    column="NAME"           property="name" />
      <result    column="GENDER"         property="gender" />
      <result    column="MOBILE"         property="mobile" />
      <result    column="POSTCODE"       property="postcode" />
      <result    column="ROAD_ADDRESS"   property="roadAddress" />
      <result    column="JIBUN_ADDRESS"  property="jibunAddress" />
      <result    column="DETAIL_ADDRESS" property="detailAddress" />
      <result    column="AGREE"          property="agree" />
      <result    column="STATE"          property="state" />
      <result    column="PW_MODIFIED_AT" property="pwModifiedAt" />
      <result    column="JOINED_AT"      property="joinedAt" />
    </association>
  </resultMap>
  
-- 추가할 부분 :  <select id="getCommentList" parameterType="Map" resultMap="CommentMap">   <-- resultMap 부분 추가.

 
17. 서비스임플 수정
CommentDto comment = CommentDto.builder()
                           .contents(contents)
                           .userDto(UserDto.builder()
                                     .userNo(userNo)
                                     .build())
                           .blogNo(blogNo)
                           .build();
                           
                           
                           
                           
18. detail.jsp 작성
  // 전역 변수
  var page = 1;
  
  const fnCommentList = () => {
	$.ajax({
	  // 요청
	  type: 'get',
	  url: '${contextPath}/blog/commentList.do'
	  data: 'page=' + page + '&blogNo=${blog.blogNo}'
	  // 응답
	  dataType: 'json',
	  success: (resData) => {

	  }
	})
  }
  
  fnRequiredLogin();
  fnCommentAdd();
  fnCommentList();
  
  
  
19. 서비스 작성
public Map<String, Object> loadCommentList(HttpServletRequest request);



20. 서비스 임플 작성
  @Override
  public Map<String, Object> loadCommentList(HttpServletRequest request) {

    int blogNo = Integer.parseInt(request.getParameter("blogNo"));
    
    int page = Integer.parseInt(request.getParameter("page"));
    int total = blogMapper.getCommentCount(blogNo);
    int display = 10;
    
    myPageUtils.setPaging(page, total, display);
    
    Map<String, Object> map = Map.of("blogNo", blogNo
                                   , "begin", myPageUtils.getBegin()
                                   , "end", myPageUtils.getEnd());
    
    List<CommentDto> commentList = blogMapper.getCommentList(map);
    String paging = myPageUtils.getAjaxPaging();
    
    Map<String, Object> result = new HashMap<String, Object>();
    result.put("commentList", commentList);
    result.put("paging", paging);
    return result;
    
  }
  


21. 컨트롤러 작성
  @ResponseBody
  @GetMapping(value="/commentList.do", produces="application/json")
  public Map<String, Object> commentList(HttpServletRequest request){
    return blogService.loadCommentList(request);
  }


  
22. detail.jsp 에 추가 작성 ( 및 수정 )
<!-- 블로그 댓글 목록 -->
  <div style="width: 100%; border-bottom: 1px solid gray;"></div>  <!-- div로 써놨지만, 사실은 회색 선이다. -->
  <div id="comment_list"></div>
  <div id="paging"></div>
  
  <script>
    
    const fnRequiredLogin = () => {       
        // 로그인을 안하고 작성을 시도하면 로그인 페이지로 보내기
        $('#contents, #btn_comment_add').click(() => {
          if('${sessionScope.user}' === ''){
            if(confirm('로그인이 필요한 기능입니다. 로그인할까요?')){
              location.href = '${contextPath}/user/login.form';
            } else {
              return;
            }
          }
        })
      }
      
      const fnCommentAdd = () => {
        $('#btn_comment_add').click(() => {
          $.ajax({
            // 요청
            type: 'post',
            url: '${contextPath}/blog/addComment.do',
            data: $('#frm_comment_add').serialize(),
            // 응답
            dataType: 'json',
            success: (resData) => {   // {"addCommentResult": 1}
            if(resData.addCommentResult === 1){
              alert('댓글이 등록되었습니다.');
              fnCommentList();
            }
            }
          })
        })
      }
      
      // 전역 변수
      var page = 1;
      
      const fnCommentList = () => {
      $.ajax({
        // 요청
        type: 'get',
        url: '${contextPath}/blog/commentList.do'
        data: 'page=' + page + '&blogNo=${blog.blogNo}'
        // 응답
        dataType: 'json',
        success: (resData) => { // resData = {"commentList": [], "paging": "<div>...</di>"}
		  $('#comment_list').empty();
          $('#paging').empty();
          if(resData.commentList.length === 0){
			$('#comment_list').text('첫 번째 댓글의 주인공이 되어 보세요');
			$('#paging').text('');
		  	return;
          }
          $.each(resData.commentList, (i, c) => {
            let str = '<div>';
            if(c.depth === 0){
              str += '<div style="width: 100%; border-bottom: 1px solid gray;">';
            } else {															  // 꼭 구현할 모양을 같이 적어가면서 쓰기.
              str += '<div style="width: 100%; border-bottom: 1px solid gray; margin-left: 32px;">';							// <div>
            }
            str += '<div>' + c.userDto.name + '</div>';							    // <div>이름</div>
            str += '<div>' + c.contents + '</div>';		    						// <div>내용</div>
            str += '<div style="font-size: 12px;">' + c.createdAt + '</div>';		// <div>작성일자</div>
            str += '</div>';												 		// </div>
            $('#comment_list').append(str);  // comment_list 에 저장.
          })
          $('#paging').append(resData.paging);  // fnAjaxPaging() 함수가 호출되는 곳
        }
      })
    }
      
      const fnAjaxPaging = (p) => {
    	page = p;  // 페이지를 막아줘
    	fnCommentList(); // 몇페이지로 바뀔거다. 라는 새 목록 갱신.
      }
      
      fnRequiredLogin();
      fnCommentAdd();
      fnCommentList();
      
      
    </script>  	
    
    
    
23. detail.jsp 작성
<!-- 블로그 상세보기 -->
  <div>
    <h1>${blog.title}</h1>
    <div>작성자 : ${blog.userDto.name}</div>
    <div>조회수 : ${blog.hit}</div>
    <div>작성IP : ${blog.ip}</div>
    <div>작성일 : ${blog.createdAt}</div>
    <div>수정일 : ${blog.modifiedAt}</div>
    <div>
      <c:if test="${sessionScope.user.userNo == blog.userDto.userNo}"> <!-- 작성자가 맞다면(로그인되어있다면) -->
      <form id="frm_btn" method="post">
       <input type="hidden" name="blogNo" value="${blog.blogNo}"> <!-- blogNo : 블로그 번호를 키값으로 포함시켜야 된다. -->
        <button type="button" id="btn_edit">편집</button>
        <button type="button" id="btn_remove">삭제</button>
      </form>
     </c:if>
    </div>
    <div>${blog.contents}</div>
  </div>
  <script>
  
   var frmBtn = $('#frm_btn');
   
  	const fnEditBlog = () => {  // 변수를 저장할 때, 함수를 등록시키면 변수가 함수가 된다.
  		$('#btn_edit').click(() => {
  		  frmBtn.attr('action', '${contextPath}/blog/edit.form');
  		  frmBtn.submit();
  		})		
  	}
  	
  	const fnRemoveBlog = () => {
  		$('#btn_remove').click(() => {
  		  if(confirm('블로그를 삭제하면 모든 댓글이 함께 삭제됩니다. 삭제할까요?')){
  	 		frmBtn.attr('action', '${contextPath}/blog/remove.do');
  	  		frmBtn.submit();
  		  }
  		})
  	}
  
  	fnEditBlog();
  	fnRemoveBlog();
  	
24. servlet-context.xml 작성
<interceptor>
    <mapping path="/user/mypage.form"/>
    <mapping path="/user/modifyPw.form"/>
    <mapping path="/free/write.form"/>
    <mapping path="/blog/write.form"/>
    <mapping path="/blog/edit.form"/>		// 이거 추가
    <mapping path="/blog/remove.do"/>	    // 이거 추가
    <beans:bean class="com.gdu.myhome.intercept.RequiredLoginInterceptor" />  <!-- 로그인체크가 필요할 때 : 필수 로그인 인터셉터 : RequiredLoginInterceptor -->
</interceptor>



25. 컨트롤러 작성
  @PostMapping("/edit.form")
  public String edit(@RequestParam(value="blogNo", required=false, defaultValue="0") int blogNo
                   , Model model) {
    BlogDto blog = blogService.getBlog(blogNo);
    model.addAttribute("blog", blog);
    return "blog/edit";  // edit.jsp 에 가서 블로그 편집을 하겠다.
  }


26. edit.jsp 만들기
<div>
  <!-- form id="frm_blog_add"는 title의 공백을 검사할 때 사용한다.(지금은 사용 안한 버젼 -->
  <form style="text-align: center;" id="frm_blog_modify" method="post" action="${contextPath}/blog/modifyBlog.do">
    
    <h1 style="text-align: center;">${blog.blogNo}번 블로그 편집</h1>
    
    <div>
     <label for="title">제목</label>
     <input type="text" name="title" id="title" class="form-control" value="${blog.title}">
    </div>
    
    <div>
     <label for="contents">내용</label>
     <textarea name="contents" id="contents">${blog.contents}e</textarea>
    </div>
    
    <div>
     <input type="hidden" name="blogNo" value="${blog.blogNo}"> <!-- 세션에 있는 유저에 있는 유저넘버 -->
     <button type="submit" class="btn btn-success">수정완료</button>
</div>



27. 매퍼.xml 작성
  <update id="updateBlog" parameterType="BlogDto">
    UPDATE BLOG_T
       SET TITLE = #{title}
         , CONTENTS = #{contents}
         , MODIFIED_AT = TO_CHAR(SYSDATE, 'YYYY-MM-DD HH:MI:SS')
     WHERE BLOG_NO = #{blogNo}
  </update>

  
  
28. 매퍼.java 작성
public int updateBlog(BlogDto blog);


29. 서비스 작성
public int modifyBlog(HttpServletRequest request);



30. 서비스임플 작성
  @Override
  public int modifyBlog(HttpServletRequest request) {
    
    String title = request.getParameter("title");
    String contents = request.getParameter("contents");
    int blogNo = Integer.parseInt(request.getParameter("blogNo"));
    
    BlogDto blog = BlogDto.builder()
                    .title(title)
                    .contents(contents)
                    .blogNo(blogNo)
                    .build();
    
    int modifyResult = blogMapper.updateBlog(blog);
    
    return modifyResult;

  }

31. 컨트롤러 작성
  @PostMapping("/modifyBlog.do")
  public String modifyBlog(HttpServletRequest request, RedirectAttributes redirectAttributes) {
    int modifyResult = blogService.modifyBlog(request);
    redirectAttributes.addFlashAttribute("modifyResult", modifyResult);
    return "redirect:/blog/detail.do?blogNo=" + request.getParameter("blogNo");  // 수정이후에 상세보기로 넘어가는 걸 볼 수 있다.
  }
  
  
  
32. 매퍼.xml 작성
  <delete id="deleteBlog" parameterType="int">
    DELETE
      FROM BLOG_T
     WHERE BLOG_NO = #{blogNo}
  </delete>

  
33. 매퍼.java 작성
public int deleteBlog(int blogNo);


34. 서비스 작성
public int removeBlog(int blogNo);


35. 서비스임플 작성
  @Override
  public int removeBlog(int blogNo) {
    return blogMapper.deleteBlog(blogNo);
  }
  
  

36. 컨트롤러 작성
  @PostMapping("/remove.do")
  public String remove(@RequestParam(value="blogNo", required=false, defaultValue="0") int blogNo
                     , RedirectAttributes redirectAttributes) {
    int removeResult = blogService.removeBlog(blogNo);
    redirectAttributes.addFlashAttribute("removeResult", removeResult);
    return "redirect:/blog/list.do";
  }
  
-------------------------------------------------------  
  
[ 댓글에 다는 답글의 삽입 및 삭제기능 순서 ]


1.detail.jsp  (기존 것 수정 : 답글 달기)
     // 전역 변수
      var page = 1;
      
      const fnCommentList = () => {
      $.ajax({
        // 요청
        type: 'get',
        url: '${contextPath}/blog/commentList.do',
        data: 'page=' + page + '&blogNo=${blog.blogNo}',
        // 응답
        dataType: 'json',
        success: (resData) => { // resData = {"commentList": [], "paging": "<div>...</di>"}
		  $('#comment_list').empty();
          $('#paging').empty();
          if(resData.commentList.length === 0){
			$('#comment_list').text('첫 번째 댓글의 주인공이 되어 보세요');
			$('#paging').text('');
		  	return;
          }
          $.each(resData.commentList, (i, c) => {
            let str = '';
            if(c.depth === 0){
              str += '<div style="width: 100%; border-bottom: 1px solid gray;">';
            } else {															  // 꼭 구현할 모양을 같이 적어가면서 쓰기.
              str += '<div style="width: 100%; border-bottom: 1px solid gray; margin-left: 32px;">';						
            }																	   		     
            str += '  <div>' + c.userDto.name + '</div>';							         
            str += '  <div>' + c.contents + '</div>';		    						        
            str += '  <div style="font-size: 12px;">' + c.createdAt + '</div>';	            
            if(c.depth === 0){		// depth가 0이면 답글달기 버튼을 보여주자.
              str += '  <div><button type="button" class="btn_open_reply"> 답글달기</button></div>'; 
            }
            /************************** 답글 입력 창 **************************/
            str += '  <div class="blind">';
            str += '    <form class="frm_add_reply">';
            str += '      <textarea rows="3" cols="50" name="contents" placeholder="답글을 입력하세요"></textarea>';
            str += '      <input type="hidden" name="userNo" value="${sessionScope.user.userNo}">';
            str += '      <input type="hidden" name="blogNo" value="${blog.blogNo}">';
            str += '      <input type="hidden" name="groupNo" value="' + c.groupNo + '">';
            str += '      <button type="button" class="btn_add_reply">답글작성완료</button>';
            str += '    </form>';
            str += '  </div>';
            /******************************************************************/
            str += '</div>';												 			  		
            $('#comment_list').append(str);  // comment_list 에 저장.
          })
          $('#paging').append(resData.paging);  // fnAjaxPaging() 함수가 호출되는 곳
        }
      })
    }
    

2. 매퍼.xml 작성
  <insert id="insertCommentReply" parameterType="CommentDto">
    INSERT INTO COMMENT_T(
        COMMENT_NO
      , CONTENTS
      , USER_NO
      , BLOG_NO
      , CREATED_AT
      , STATUS
      , DEPTH
      , GROUP_NO
    ) VALUES(
        COMMENT_SEQ.NEXTVAL
      , #{contents}
      , #{userDto.userNo}
      , #{blogNo}
      , TO_CHAR(SYSDATE, 'YYYY-MM-DD HH:MI:SS')  <!-- CREATED_AT -->
      , 1   <!-- DEPTH -->
      , 1   <!-- GROUP_NO. 답글은 1이다.  --> 
      , #{groupNo}
    )
  </insert>
  
  
  
3. 매퍼.java 작성
public int insertCommentReply(CommentDto comment);



4. 서비스 작성
public Map<String, Object> addCommentReply(HttpServletRequest request);



5. 서비스임플 작성 (addComment 와 본문이 흡사함)
  @Override
  public Map<String, Object> addCommentReply(HttpServletRequest request) {

    String contents = request.getParameter("contents");
    int userNo = Integer.parseInt(request.getParameter("userNo"));
    int blogNo = Integer.parseInt(request.getParameter("blogNo"));
    int groupNo = Integer.parseInt(request.getParameter("groupNo"));
    
    CommentDto comment = CommentDto.builder()
                           .contents(contents)
                           .userDto(UserDto.builder()
                                     .userNo(userNo)
                                     .build())
                           .blogNo(blogNo)
                           .groupNo(groupNo)
                           .build();
    
    int addCommentReplyResult = blogMapper.insertCommentReply(comment);
    
    return Map.of("addCommentReplyResult",addCommentReplyResult);
    
  }
  
  


6. 컨트롤러 작성 (addComment와 본문 같음 : 이름들만 바꾸기)
  @ResponseBody
  @PostMapping(value="/addCommentReply.do", produces="application/json")
  public Map<String, Object> addCommentReply(HttpServletRequest request) {
    return blogService.addCommentReply(request);
  }



7. detail.jsp 작성
----------------------------------------------------------
const fnCommentReplyAdd = () => {
    	$(document).on('click', '.btn_add_reply', (ev) => {	// 위 상황처럼 버튼을 사용할 수 없을 때 사용하는 방법 : document 방식.
    	  var frmAddReply = $(ev.target).closest('.frm_add_reply'); 
       	  $.ajax({
       		 // 요청
       		 type: 'post',
       		 url: '${contextPath}/blog/addCommentReply.do',
       		 data: frmAddReply.serialize(),	// 클릭한 버튼의 부모(.frm_add_reply)클래스의 모든 요소를 보내 준다.
       	     // 응답
       	     dataType: 'json',
       	     success: (resData) => {	// resData = {"addCommentReplyResult": 1}
       	       if(resData.addCommentReplyResult === 1){
       	    	  alert('답글이 등록되었습니다.');
       	    	  fnCommentList();	 // 목록 갱신하는 함수 호출
       	    	  frmAddReply.find('textarea').val(''); // 답글내용 초기화 , find : 자식 찾는 메소드
       	       } else {
       	    	  alert('답글이 등록되지 않았습니다.');
       	       }
       	     }
       	  })
    	})
      }
------------------------------------------------------------


[답글 삭제 기능]

1. detail.jsp 작성
/************************** 답글 입력 창 **************************/
str += '  <div class="blind">';
str += '    <form class="frm_add_reply">';
str += '      <textarea rows="3" cols="50" name="contents" placeholder="답글을 입력하세요"></textarea>';
str += '      <input type="hidden" name="userNo" value="${sessionScope.user.userNo}">';
str += '      <input type="hidden" name="blogNo" value="${blog.blogNo}">';
str += '      <input type="hidden" name="groupNo" value="' + c.groupNo + '">';
str += '      <button type="button" class="btn_add_reply">답글작성완료</button>';
str += '    </form>';
str += '  </div>';
/******************************************************************/
str += '  <div>';															 <- 추가
str += '    <input type="hidden" value="' + c.commentNo + '">';		         <- 추가
str += '    <button type="button" class="btn_remove_comment">삭제</button>'; <- 추가
str += '  </div>';												 			 <- 추가 		
str += '</div>';												 			  		


2. 매퍼.xml 작성
  <update id="deleteComment" parameterType="int">
    UPDATE COMMENT_T
       SET STATUS = 0
     WHERE COMMENT_NO = #{commentNo}
  </update>  <!-- status 값을 0 에서 1로 바꿔주는 것이기 때문에 delete가 아니라 update이다. -->		
  
  
3. 매퍼.java 작성
public int deleteComment(int commentNo);

4. 서비스 작성
public Map<String, Object> removeComment(int commentNo);


5. 서비스임플 작성
  @Override
  public Map<String, Object> removeComment(int commentNo) {
    int removeResult = blogMapper.deleteComment(commentNo);
    return Map.of("removeResult", removeResult);
    
  }

6. 컨트롤러 작성
   @ResponseBody
   @PostMapping(value="/removeComment.do", produces="application/json")              // defaultValue를 안하면 에러날 수도 있어서 넣음
   public Map<String, Object> removeComment(@RequestParam(value="commentNo", required = false, defaultValue = "0") int commentNo) { 
     return blogService.removeComment(commentNo);
   }
	
	
		
7. detail.jsp 작성
  const fnCommentRemove = () => {
  	$(document).on('click', '.btn_remove_comment', (ev) => {
  		if(!confirm('해당 댓글을 삭제할까요?')){
  			return;
  		}
  		$.ajax({
  			// 요청
  			type: 'post',
  			url: '${contextPath}/blog/removeComment.do',
  			data: 'commentNo=' + $(ev.target).prev().val(),	  // prev() : 인접형제.
  			// 응답
  			dataType: 'json',
  			success: (resData) => {  // resData = {"removeResult": 1}
  				if(resData.removeResult === 1){
  					alert('해당 댓글이 삭제되었습니다.');
  					fnCommentList();
  				} else {
  					alert('댓글이 삭제되지 않았습니다.');
  				}
  			}
  		})
  	})
  }
  
  fnRequiredLogin();
  fnCommentAdd();
  fnCommentList();
  fnCommentReplyAdd();
  fnCommentRemove();		 	
  
/*************<주석내용>*****************************************************
      <div style="width: 100%; border-bottom: 1px solid gray;">
      
        // 삭제된 댓글/답글
        <div>삭제된 댓글입니다.</div>
        
        // 정상 댓글/답글
        <div>이름</div>
        <div>내용</div>
        <div style="font-size: 12px;">작성일자</div>
        <div><button type="button" class="btn_open_reply"> 답글달기</button></div>
        <div class="blind">
          <form class="frm_add_reply"
          <textarea rows="3" cols="50" name="contents" placeholder="답글을 입력하세요"></textarea>
          <input type="hidden" name="userNo" vlaue="">  
          <input type="hidden" name="blogNo" vlaue="">  
          <input type="hidden" name="groupNo" vlaue="">  
          <button type="button" class="btn_add_reply">답글작성완료</button>
          </form>
        </div>
        <input type="hidden" value="commentNo">
        <div><button type="button" class="btn_remove_comment">삭제</button></div>
      </div>
****************<주석내용>*****************************************************/
   
   
   
   
8. detail.jsp 추가 작성 (기존 내용 수정 및 추가) - 삭제된 댓글.
$.each(resData.commentList, (i, c) => {
    let str = '';
    if(c.depth === 0){
      str += '<div style="width: 100%; border-bottom: 1px solid gray;">';
    } else {															  // 꼭 구현할 모양을 같이 적어가면서 쓰기.
      str += '<div style="width: 100%; border-bottom: 1px solid gray; margin-left: 32px;">';						
    }
    if(c.status === 0){
      str += '<div>삭제된 댓글입니다.</div>';
    } else {
      str += '  <div>' + c.userDto.name + '</div>';							         
      str += '  <div>' + c.contents + '</div>';		    						        
      str += '  <div style="font-size: 12px;">' + c.createdAt + '</div>';	            
      if(c.depth === 0){		// depth가 0이면 답글달기 버튼을 보여주자.
        str += '  <div><button type="button" class="btn_open_reply"> 답글달기</button></div>'; 
      }
      /************************** 답글 입력 창 **************************/
      str += '  <div class="blind frm_add_reply_wrap">';   // 클래스를 더 주고 싶으면 공백으로 구분하여 작성.
      str += '    <form class="frm_add_reply">';
      str += '      <textarea rows="3" cols="50" name="contents" placeholder="답글을 입력하세요"></textarea>';
      str += '      <input type="hidden" name="userNo" value="${sessionScope.user.userNo}">';
      str += '      <input type="hidden" name="blogNo" value="${blog.blogNo}">';
      str += '      <input type="hidden" name="groupNo" value="' + c.groupNo + '">';
      str += '      <button type="button" class="btn_add_reply">답글작성완료</button>';
      str += '    </form>';
      str += '  </div>';
      /******************************************************************/
      str += '  <div>';
      str += '    <input type="hidden" value="' + c.commentNo + '">';
      str += '    <button type="button" class="btn_remove_comment">삭제</button>';
      str += '  </div>';	
	}
    str += '</div>';	
    


9. detail.jsp 작성 (기존 것 수정) - 자기가 작성한 것만 삭제버튼이 보이게 하기.
 /******************************************************************/
  if('${sessionScope.user.userNo}' == c.userDto.userNo){   // 자바스크립트의 특징 : 등호 ==. true값 (===와 ==는 다름)
    str += '  <div>';
    str += '    <input type="hidden" value="' + c.commentNo + '">';
    str += '    <i class="fa-solid fa-trash ico_remove_comment"></i>';  // 공백으로 클래스끼리 구분한다. <-- btn을 ico(아이콘)으로 변경했으므로 이름도 ico로 바꿔줌.
    str += '  </div>';												 			  		   	
  }
  
  
  
------하단 수정------
const fnCommentRemove = () => {
      	$(document).on('click', '.ico_remove_comment', (ev) => {	<-- btn을 ico(아이콘)으로 변경했으므로 이름도 ico로 바꿔줌.
      		if(!confirm('해당 댓글을 삭제할까요?')){


      		
------최상단에 추가-------
<!--선택하는 느낌이 나도록 커서 넣어주기-->
<<style>
  .blind {
    display: none;
  }
  .ico_remove_comment {
    cursor: pointer;
  }
</style>


-------내용 추가--------

   const fnBlind = () => {
	  $(document).on('click', '.btn_open_reply', (ev) => {
	  if('${sessionScope.user}' === ''){
  	      if(confirm('로그인이 필요한 기능입니다. 로그인할까요?')){
  	         location.href = '${contextPath}/user/login.form';
  	      } else {
  	        return;
  	      }
  	  }
        var blindTarget = $(ev.target).parent().next();
        if(blindTarget.hasClass('blind')){
          $('.frm_add_reply_wrap').addClass('blind'); // 모든 답글 입력화면 닫기
        	blindTarget.removeClass('blind');		  // 지금 타겟의 답글만 입력화면 열기
        } else {
          blindTarget.addClass('blind');
        }
	 })
  }


  fnRequiredLogin();
  fnCommentAdd();
  fnCommentList();
  fnBlind();			<-- 이것도 추가
  fnCommentReplyAdd();
  fnCommentRemove();

------------ 이 부분 아예 다 지우기 ↓↓↓↓↓ --------------
 const fnRequiredLogin = () => {       
        // 로그인을 안하고 작성을 시도하면 로그인 페이지로 보내기
        $('#contents, #btn_comment_add, .btn_open_reply, .btn_add_reply').click(() => {   // <-- 4개의 요소들은 클릭했을 때 로그인여부 검사.
          if('${sessionScope.user}' === ''){
            if(confirm('로그인이 필요한 기능입니다. 로그인할까요?')){
              location.href = '${contextPath}/user/login.form';
            } else {
              return;
            }
          }
        })
      }
      
      
------------------ 기존내용에 추가하기 ---------------------
      const fnCommentAdd = () => {
        $('#btn_comment_add').click(() => {
      	 if('${sessionScope.user}' === ''){
            if(confirm('로그인이 필요한 기능입니다. 로그인할까요?')){
                location.href = '${contextPath}/user/login.form';
            } else {
                return;
            }
         }
          $.ajax({
           // 요청
           
           
------------------ 기존내용에 추가하기2 ---------------------
        const fnBlind = () => {
    	  $(document).on('click', '.btn_open_reply', (ev) => {
  		    if('${sessionScope.user}' === ''){
  	          if(confirm('로그인이 필요한 기능입니다. 로그인할까요?')){
  	                location.href = '${contextPath}/user/login.form';
  	          } else {
  	            return;
  	          }
  	        }
            var blindTarget = $(ev.target).parent().next();
            if(blindTarget.hasClass('blind')){
              $('.frm_add_reply_wrap').addClass('blind'); // 모든 답글 입력화면 닫기
            	blindTarget.removeClass('blind');		  // 지금 타겟의 답글만 입력화면 열기
            } else {
              blindTarget.addClass('blind');
            }
    	 })
      }
      
      
------------------ 기존내용에 추가하기3 ---------------------  
      const fnCommentReplyAdd = () => {
    	$(document).on('click', '.btn_add_reply', (ev) => {	// 위 상황처럼 버튼을 사용할 수 없을 때 사용하는 방법 : document 방식.
  		if('${sessionScope.user}' === ''){
            if(confirm('로그인이 필요한 기능입니다. 로그인할까요?')){
                location.href = '${contextPath}/user/login.form';
            } else {
              return;
            }
        }
    	  var frmAddReply = $(ev.target).closest('.frm_add_reply'); 
       	  $.ajax({
       		 // 요청
       		 
       		 
==================== 댓글형 게시판 끝 =======================


PS. 댓글형 게시판 중 전면 수정한 부분들 ↓↓↓↓↓↓↓↓↓↓


1. ShouldNotLogininterceptor.java 에서
history.back() 부분을 수정함.

수정 후 : 
out.println("location.href='" + request.getContextPath() + "/main.do'");



2. header.jsp 에서 cdn부분 전면 수정
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>${param.title == null ? '마이홈' : param.title}</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
<link rel="stylesheet" href="${contextPath}/resources/css/init.css?dt=${dt}" />
<link rel="stylesheet" href="${contextPath}/resources/css/header.css?dt=${dt}" />
<link rel="stylesheet" href="${contextPath}/resources/css/main.css?dt=${dt}" />
<link rel="stylesheet" href="${contextPath}/resources/css/footer.css?dt=${dt}" />
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
<script src="https://cdn.ckeditor.com/ckeditor5/40.0.0/decoupled-document/ckeditor.js"></script>
</head>


3. blog 폴더에  

(1) write.jsp -> 전면 수정


<jsp:include page="../layout/header.jsp">
  <jsp:param value="블로그작성" name="title"/>
</jsp:include>

<style>
  .ck.ck-editor {
    max-width: 1000px;
  }
  .ck-editor__editable {
    min-height: 400px;
  }
  .ck-content {
    color: gray;
  }
</style>

<div>

  <form id="frm_blog_add" method="post" action="${contextPath}/blog/addBlog.do">
    
    <h1 style="text-align: center;">블로그를 작성하세요</h1>
    
    <div>
      <label for="title">제목</label>
      <input type="text" name="title" id="title" class="form-control">
    </div>
    
    <div>
      <label for="contents">내용</label>
      <textarea name="contents" id="contents" style="display: none;"></textarea>
      <div id="toolbar-container"></div>
      <div id="ckeditor"></div>
    </div>
    
    <div>
      <input type="hidden" name="userNo" value="${sessionScope.user.userNo}">
      <button class="btn btn-primary col-12" type="submit">작성완료</button>
    </div>
    
  </form>

</div>

<script>

  const fnCkeditor = () => {
	  DecoupledEditor
      .create(document.getElementById('ckeditor'), {
    	  ckfinder: {
          // 이미지 업로드 경로
          uploadUrl: '${contextPath}/blog/imageUpload.do'    		  
    		}
  	  })
      .then(editor => {
        const toolbarContainer = document.getElementById('toolbar-container');
        toolbarContainer.appendChild(editor.ui.view.toolbar.element);
      })
      .catch(error => {
        console.error(error);
      });
  }
  
  const fnBlogAdd = () => {
	  $('#frm_blog_add').submit(() => {
		  $('#contents').val($('#ckeditor').html());
	  })
  }
  
  fnCkeditor();
  fnBlogAdd();
  
</script>

<%@ include file="../layout/footer.jsp" %>

-------------------------


(2) edit.jsp -> 전면 수정


<jsp:include page="../layout/header.jsp">
  <jsp:param value="블로그편집" name="title"/>
</jsp:include>

<style>
  .ck.ck-editor {
    max-width: 1000px;
  }
  .ck-editor__editable {
    min-height: 400px;
  }
  .ck-content {
    color: gray;
  }
</style>

<div>

  <form id="frm_blog_modify" method="post" action="${contextPath}/blog/modifyBlog.do">
    
    <h1 style="text-align: center;">${blog.blogNo}번 블로그 편집</h1>
    
    <div>
      <label for="title">제목</label>
      <input type="text" name="title" id="title" class="form-control" value="${blog.title}">
    </div>
    
    <div>
      <label for="contents">내용</label>
      <textarea name="contents" id="contents" style="display: none;"></textarea>
      <div id="toolbar-container"></div>
      <div id="ckeditor">${blog.contents}</div>
    </div>
    
    <div>
      <input type="hidden" name="blogNo" value="${blog.blogNo}">
      <button class="btn btn-primary col-12" type="submit">수정완료</button>
    </div>
    
  </form>

</div>

<script>

  const fnCkeditor = () => {
    DecoupledEditor
      .create(document.getElementById('ckeditor'), {
        ckfinder: {
          // 이미지 업로드 경로
          uploadUrl: '${contextPath}/blog/imageUpload.do'         
        }
      })
      .then(editor => {
        const toolbarContainer = document.getElementById('toolbar-container');
        toolbarContainer.appendChild(editor.ui.view.toolbar.element);
      })
      .catch(error => {
        console.error(error);
      });
  }
  
  const fnBlogModify = () => {
    $('#frm_blog_modify').submit(() => {
      $('#contents').val($('#ckeditor').html());
    })
  }
  
  fnCkeditor();
  fnBlogModify();
  
</script>

<%@ include file="../layout/footer.jsp" %>



==================== 댓글형 게시판 진짜 끝 =======================
